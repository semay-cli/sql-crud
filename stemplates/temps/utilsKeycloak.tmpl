package utils

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"{{.ProjectName}}/configs"
	
)

type KeycloakClient struct {
	BaseURL   string
	Realm     string
	ApiClient *ApiClient
}

func NewKeycloakClient(cfg configs.Config, apiClient *ApiClient) *KeycloakClient {
	baseURL := cfg.GetOrDefault("KEYCLOAK_BASE_URL", "http://localhost:8080")
	realm := cfg.GetOrDefault("KEYCLOAK_REALM", "myrealm")

	return &KeycloakClient{
		BaseURL:   baseURL,
		Realm:     realm,
		ApiClient: apiClient,
	}
}

// TokenIntrospectionResponse represents the response from Keycloak introspection endpoint.
type TokenIntrospectionResponse struct {
	Active      bool                `json:"active"`
	Scope       string              `json:"scope"`
	ClientId    string              `json:"client_id"`
	Username    string              `json:"username"`
	TokenType   string              `json:"token_type"`
	Exp         int64               `json:"exp"`
	Iat         int64               `json:"iat"`
	Sub         string              `json:"sub"`
	RealmAccess RealmAccessResponse `json:"realm_access"`
}

type RealmAccessResponse struct {
	Roles []string `json:"roles"`
}

// ValidateToken checks if a token is valid with Keycloak using form-urlencoded POST.
func (k *KeycloakClient) ValidateToken(ctx context.Context, token, clientID, clientSecret string) (*TokenIntrospectionResponse, error) {
	// 1. Construct the Keycloak OIDC introspection endpoint
	endpoint := fmt.Sprintf("%s/realms/%s/protocol/openid-connect/token/introspect", k.BaseURL, k.Realm)

	// 2. Prepare form-encoded payload
	form := url.Values{}
	form.Set("token", token)
	form.Set("client_id", clientID)
	form.Set("client_secret", clientSecret)

	// 3. Set specific headers for Keycloak
	headers := map[string]string{
		"Content-Type": "application/x-www-form-urlencoded",
	}

	var introResponse TokenIntrospectionResponse

	// 4. Send using the generic ApiClient
	err := k.ApiClient.Send(
		ctx,
		http.MethodPost,
		endpoint,
		headers,
		strings.NewReader(form.Encode()), // Passed as io.Reader to avoid JSON marshaling
		&introResponse,
	)

	if err != nil {
		return nil, err
	}

	return &introResponse, nil
}
