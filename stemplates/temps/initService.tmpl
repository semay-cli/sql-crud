package repository

import (
	"context"
	"{{ .ProjectName }}/cache"
	"{{ .ProjectName }}/configs"
	"gorm.io/gorm"
)



// AppDatabase Service wraps Dababase service(SQL)
type {{ .AppName | toPascalCase }}Repository struct {
	DB *gorm.DB
	Cache *cache.CacheService
	Cfg   *configs.EnvConfig
}



func InitRepository(client *gorm.DB, cacheService *cache.CacheService, cfg *configs.EnvConfig) *{{ .AppName | toPascalCase }}Repository {

	return &{{ .AppName | toPascalCase }}Repository{
		DB:    client,
		Cache: cacheService,
		Cfg:   cfg,
	}

}

// Utility function for transactions
func (s *{{ .AppName | toPascalCase }}Repository ) withTransaction(ctx context.Context, fn func(tx *gorm.DB) error) error {
    // Start the transaction with context (e.g., tracing)
    tx := s.DB.WithContext(ctx).Begin()
    if tx.Error != nil {
        return tx.Error
    }

    // Ensure rollback on panic
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    // Execute transactional logic
    if err := fn(tx); err != nil {
        tx.Rollback()
        return err
    }

    // Commit if no errors
    return tx.Commit().Error
}
