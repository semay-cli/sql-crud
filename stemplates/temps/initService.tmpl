package services

import (
	"context"
	"regexp"
	"{{ .ProjectName }}/cache"
	"{{ .ProjectName }}/configs"
	"{{ .ProjectName }}/{{ .AppName }}/repository"
	"gorm.io/gorm"
)



// AppDatabase Service wraps Dababase service(SQL)
type {{ .AppName | toPascalCase }}Service struct {
	DB *gorm.DB
	Cache *cache.CacheService
	Cfg   *configs.EnvConfig
	Repo *repository.{{ .AppName | toPascalCase }}Repository
	ForeignRegex *regexp.Regexp
    NumberRegex  *regexp.Regexp
}



func InitService(client *gorm.DB, cacheService *cache.CacheService, cfg *configs.EnvConfig, repo *repository.{{ .AppName | toPascalCase }}Repository) *{{ .AppName | toPascalCase }}Service {

	return &{{ .AppName | toPascalCase }}Service{
		DB:    client,
		Cache: cacheService,
		Cfg:   cfg,
		Repo:  repo,
        ForeignRegex: regexp.MustCompile(`(?i)_id$`), // Prepare regex to check for *_id pattern
        NumberRegex:  regexp.MustCompile(`^\d+$`),

	}

}

// Utility function for transactions
func (s *{{ .AppName | toPascalCase }}Service ) withTransaction(ctx context.Context, fn func(tx *gorm.DB) error) error {
    // Start the transaction with context (e.g., tracing)
    tx := s.DB.WithContext(ctx).Begin()
    if tx.Error != nil {
        return tx.Error
    }

    // Ensure rollback on panic
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    // Execute transactional logic
    if err := fn(tx); err != nil {
        tx.Rollback()
        return err
    }

    // Commit if no errors
    return tx.Commit().Error
}
