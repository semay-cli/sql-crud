package services

import (
	"context"
	"database/sql"
	"regexp"
	"{{ .ProjectName }}/cache"
	"{{ .ProjectName }}/configs"
	"{{ .ProjectName }}/database"
	"{{ .ProjectName }}/{{ .AppName }}/repository"
	db "{{ .ProjectName }}/{{ .AppName }}/sqlc"
	"github.com/jackc/pgx/v5"
	"gorm.io/gorm"
)



// AppDatabase Service wraps Dababase service(SQL)
type {{ .AppName | toPascalCase }}Service struct {
    SQLC  *sql.DB
	DB *gorm.DB
	Cache *cache.CacheService
    Queries *db.Queries
	Cfg   *configs.EnvConfig
	Repo *repository.{{ .AppName | toPascalCase }}Repository
	ForeignRegex *regexp.Regexp
    NumberRegex  *regexp.Regexp
}



func InitService(client *database.DBBundle, cacheService *cache.CacheService, cfg *configs.EnvConfig, repo *repository.{{ .AppName | toPascalCase }}Repository) *{{ .AppName | toPascalCase }}Service {
  
	return &{{ .AppName | toPascalCase }}Service{
        SQLC:         client.SQL,
		DB:           client.Gorm,
		Cache:        cacheService,
		Queries:      db.New(client.SQL),
		Cfg:          cfg,
		Repo:         repo,
	}

}

// Utility function for transactions
func (s *{{ .AppName | toPascalCase }}Service ) WithTransaction(ctx context.Context, fn func(tx *gorm.DB) error) error {
    // Start the transaction with context (e.g., tracing)
    tx := s.DB.WithContext(ctx).Begin()
    if tx.Error != nil {
        return tx.Error
    }

    // Ensure rollback on panic
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    // Execute transactional logic
    if err := fn(tx); err != nil {
        tx.Rollback()
        return err
    }

    // Commit if no errors
    return tx.Commit().Error
}


// Utility function for running queries within a transaction
func (s *{{ .AppName | toPascalCase }}Service) WithSqlcTransaction(ctx context.Context, fn func(tx *sql.Tx) error) error {
	// Start a new transaction
	tx, err := s.SQLC.BeginTx(ctx, nil)
	if err != nil {
		return err // Return error if transaction can't be started
	}

	// Ensure rollback on panic
	defer func() {
		if r := recover(); r != nil {
			// Rollback on panic
			tx.Rollback()
		}
	}()

	// Pass the transaction into the function and execute it
	if err := fn(tx); err != nil {
		// Rollback if the function returns an error
		tx.Rollback()
		return err
	}

	// Commit the transaction if no errors occurred
	return tx.Commit()
}


func (s *{{ .AppName | toPascalCase }}Service) WithNativeTransaction(ctx context.Context, fn func(tx pgx.Tx) error) error {
	tx, err := s.Repo.NativePool.Begin(ctx)
	if err != nil {
		return err
	}

	defer func() {
		if r := recover(); r != nil {
			tx.Rollback(ctx)
		}
	}()

	if err := fn(tx); err != nil {
		tx.Rollback(ctx)
		return err
	}

	return tx.Commit(ctx)
}
