package repository

import (
    "context"
    "fmt"
    "os"
    "testing"
    "strconv"

    "{{ .ProjectName }}/{{ .AppName }}/models"
    "{{ .ProjectName }}/cache"
    "{{ .ProjectName }}/configs"
    "{{ .ProjectName }}/database"
    "{{ .ProjectName }}/logs"
)

func setup{{ .Name }}TestRepo(t *testing.T) (*{{ .AppName | toPascalCase }}Repository, func()) {
    os.Setenv("{{ .AppName | replaceStringCapitalize }}_DB_TYPE", "sqlite")
    os.Setenv("{{ .AppName | replaceStringCapitalize }}_SQLLITE_URI", ":memory:")

    cfg, _ := configs.NewEnvConfig()
    logger := logs.NewZapLogger()

    bundle, err := database.ReturnSession("{{ .AppName | replaceString }}", cfg, logger)
    if err != nil {
        t.Fatalf("failed to connect to test db: %v", err)
    }

    if err := bundle.Gorm.AutoMigrate(&models.{{ .Name }}{}); err != nil {
        t.Fatalf("failed to migrate: %v", err)
    }

    cacheSvc, _ := cache.NewCacheService(cfg)
    repo := InitRepository(bundle, cacheSvc, cfg)

    cleanup := func() {
        os.Unsetenv("{{ .AppName | replaceStringCapitalize }}_DB_TYPE")
        os.Unsetenv("{{ .AppName | replaceStringCapitalize }}_SQLLITE_URI")
    }

    return repo, cleanup
}

// --- CRUD + Full Lifecycle Test ---
func Test{{ .Name }}Repo_FullLifecycle(t *testing.T) {
    repo, cleanup := setup{{ .Name }}TestRepo(t)
    defer cleanup()

    ctx := context.Background()

    // 1️⃣ Prepare field values dynamically
    {{- range .Fields }}
    {{- if .Post }}
    {{- if eq .Type "string" }}
    {{ .LowerName }}Val := {{ randomString | printf "%q" }}
    {{- else if eq .Type "bool" }}
    {{ .LowerName }}Val := {{ randomBool }}
    {{- else if eq .Type "time.Time" }}
    {{ .LowerName }}Val := {{ randomTime | printf "%q" }}
    {{- else if .ForeignKeyModel }}
    {{ .LowerName }}Val := uint64Ptr({{ randomUInt }}) // always use uint64Ptr for foreign keys
    {{- else if eq .Type "*uint64" }}
    {{ .LowerName }}Val := uint64Ptr({{ randomUInt }})
    {{- else }}
    {{ .LowerName }}Val := {{ .Type }}Ptr({{ randomUInt }})
    {{- end }}
    {{- end }}
    {{- end }}

    // 2️⃣ Create Post object
    post := &models.{{ .Name }}Post{
        {{- range .Fields }}
        {{- if .Post }}
        {{- if eq .Type "string" }}
        {{ .Name }}: sPtr({{ .LowerName }}Val),
        {{- else if eq .Type "bool" }}
        {{ .Name }}: boolPtr({{ .LowerName }}Val),
        {{- else if eq .Type "time.Time" }}
        {{ .Name }}: timePtr(parseTime({{ .LowerName }}Val)),
        {{- else if .ForeignKeyModel }}
        {{ .Name }}: uint64Ptr({{ .LowerName }}Val),
        {{- else }}
        {{ .Name }}: {{ .LowerName }}Val,
        {{- end }}
        {{- end }}
        {{- end }}
    }

    out := &models.{{ .Name }}{}
    if err := repo.Create{{ .Name }}(ctx, post, nil, out); err != nil {
        t.Fatalf("failed to create: %v", err)
    }

    // Convert ID to string for further calls
    idStr := fmt.Sprintf("%v", out.ID)

    // 3️⃣ Test GetOne
    getOut := &models.{{ .Name }}{}
    if err := repo.GetOne{{ .Name }}(ctx, idStr, getOut); err != nil {
        t.Fatalf("failed to get one: %v", err)
    }

    // 4️⃣ Test List / GetByFields
    listOut := make([]models.{{ .Name }}Get, 0)
    searchTerm := make(map[string]string)
    {{- if gt (len .SearchFields) 0 }}
    {{- $searchField := index .SearchFields 0 }}
    searchTerm["{{ $searchField | getBase }}"] = fmt.Sprintf("%v", out.{{ $searchField | getBase | toPascalCase }})
    {{- end }}
    total, err := repo.Get{{ .Name }}s(ctx, models.Pagination{Page: 1, Size: 10}, searchTerm, &listOut)
    if err != nil {
        t.Fatalf("failed to get list: %v", err)
    }
    if total == 0 {
        t.Errorf("expected count > 0, got %d", total)
    }

    // 5️⃣ Test Update (pick first patchable field)
    {{- $foundPatch := false }}
    {{- range .Fields }}
    {{- if and .Patch (not $foundPatch) }}
        {{- $foundPatch = true }}
    patchVal := {{ if eq .Type "string" }}{{ randomString | printf "%q" }}{{ else if eq .Type "bool" }}{{ randomBool }}{{ else if eq .Type "time.Time" }}{{ randomTime | printf "%q" }}{{ else if .ForeignKeyModel }}uint64({{ randomUInt }}){{ else if eq .Type "*uint64" }}uint64Ptr({{randomUInt}}){{ else }}{{ .Type }}({{ .RandomFieldValue }}){{ end }}
    patch := &models.{{ $.Name }}Patch{
        {{- if eq .Type "string" }}
        {{ .Name }}: &patchVal,
        {{- else if eq .Type "bool" }}
        {{ .Name }}: boolPtr(patchVal),
        {{- else if eq .Type "time.Time" }}
        {{ .Name }}: timePtr(parseTime(patchVal)),
        {{- else if .ForeignKeyModel }}
        {{ .Name }}: uint64Ptr(patchVal),
        {{- else }}
        {{ .Name }}: &patchVal,
        {{- end }}
    }
    updateOut := &models.{{ $.Name }}{}
    if err := repo.Update{{ $.Name }}(ctx, idStr, patch, nil, updateOut); err != nil {
        t.Fatalf("failed to update: %v", err)
    }
    {{- end }}
    {{- end }}

    // 6️⃣ Test Delete
    if err := repo.Delete{{ .Name }}(ctx, idStr, nil); err != nil {
        t.Fatalf("failed to delete: %v", err)
    }
}

// --- Batch Create ---
func Test{{ .Name }}Repo_BatchCreate(t *testing.T) {
    repo, cleanup := setup{{ .Name }}TestRepo(t)
    defer cleanup()

    ctx := context.Background()

    batchItems := []models.{{ .Name }}Post{
        {{- range $i := seq 2 }} // generate 2 items
        {
            {{- range $.Fields }}
            {{- if .Post }}
            {{- if eq .Type "string" }}
            {{ .Name }}: sPtr({{ randomString | printf "%q" }}),
            {{- else if eq .Type "bool" }}
            {{ .Name }}: boolPtr({{ randomBool }}),
            {{- else if eq .Type "time.Time" }}
            {{ .Name }}: timePtr(parseTime({{ randomTime | printf "%q" }})),
            {{- else if .ForeignKeyModel }}
            {{ .Name }}: uint64Ptr({{ randomUInt }}),
            {{- else if eq .Type "*uint64" }}
            {{ .Name }}: uint64Ptr({{ randomUInt }}),
            {{- else }}
            {{ .Name }}: {{ .Type }}Ptr({{ randomUInt }}),
            {{- end }}
            {{- end }}
            {{- end }}
        },
        {{- end }}
    }

    if err := repo.BatchCreate{{ .Name }}s(ctx, batchItems, nil); err != nil {
        t.Fatalf("failed to batch create: %v", err)
    }
}
