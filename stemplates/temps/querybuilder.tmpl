package querybuilder

import (
	"strconv"
	"strings"
	"sync"
)

var (
	// Pre-compute $1..$100
	postgresPlaceholders []string

	bufferPool = sync.Pool{
		New: func() any {
			b := make([]byte, 0, 5120)
			return &b
		},
	}
)

func init() {
	postgresPlaceholders = make([]string, 101)
	for i := 1; i <= 100; i++ {
		postgresPlaceholders[i] = "$" + strconv.Itoa(i)
	}
}

type sqlMode int

const (
	modeSelect sqlMode = iota
	modeInsert
	modeUpdate
	modeDelete
)

type Builder struct {
	mode        sqlMode
	table       string
	columns     []string
	values      []any
	setClauses  []string
	joinClauses []string
	batchValues [][]any
	where       []string
	groupBy     []string
	having      []string
	args        []any
	order       string
	limit       int
	offset      int
	suffix      string

	isPostgres bool
	isBatch    bool
	colCount   int
}

var builderPool = sync.Pool{
	New: func() any {
		return &Builder{
			columns:     make([]string, 0, 32),
			values:      make([]any, 0, 32),
			setClauses:  make([]string, 0, 24),
			joinClauses: make([]string, 0, 16),
			where:       make([]string, 0, 16),
			groupBy:     make([]string, 0, 8),
			having:      make([]string, 0, 8),
			args:        make([]any, 0, 32),
		}
	},
}

func GetBuilder(isPostgres bool) *Builder {
	b := builderPool.Get().(*Builder)

	b.mode = modeSelect
	b.table = ""
	b.order = ""
	b.suffix = ""
	b.limit = 0
	b.offset = 0
	b.isBatch = false
	b.colCount = 0
	b.isPostgres = isPostgres

	b.columns = b.columns[:0]
	b.values = b.values[:0]
	b.setClauses = b.setClauses[:0]
	b.joinClauses = b.joinClauses[:0]
	b.batchValues = b.batchValues[:0]
	b.where = b.where[:0]
	b.groupBy = b.groupBy[:0]
	b.having = b.having[:0]
	b.args = b.args[:0]

	return b
}

/* ---------- Builder API ---------- */

func (b *Builder) Select(cols ...string) *Builder {
	b.mode = modeSelect
	b.columns = append(b.columns, cols...)
	return b
}

func (b *Builder) Insert(table string) *Builder {
	b.mode = modeInsert
	b.table = table
	return b
}

func (b *Builder) BatchInsert(table string, columns []string, rows ...[]any) *Builder {
	b.mode = modeInsert
	b.table = table
	b.columns = append(b.columns, columns...)
	b.batchValues = append(b.batchValues, rows...)
	b.isBatch = true
	b.colCount = len(columns)
	return b
}

func (b *Builder) Update(table string) *Builder {
	b.mode = modeUpdate
	b.table = table
	return b
}

func (b *Builder) Delete(table string) *Builder {
	b.mode = modeDelete
	b.table = table
	return b
}

func (b *Builder) From(table string) *Builder {
	b.table = table
	return b
}

func (b *Builder) Join(join string) *Builder {
	b.joinClauses = append(b.joinClauses, join)
	return b
}

func (b *Builder) JoinArgs(join string, args ...any) *Builder {
	b.joinClauses = append(b.joinClauses, join)
	b.args = append(b.args, args...)
	return b
}

func (b *Builder) Columns(cols ...string) *Builder {
	b.columns = append(b.columns, cols...)
	return b
}

func (b *Builder) Values(vals ...any) *Builder {
	b.values = append(b.values, vals...)
	return b
}

func (b *Builder) Set(col string, val any) *Builder {
	b.setClauses = append(b.setClauses, col+" = ?")
	b.args = append(b.args, val)
	return b
}

func (b *Builder) SetExpr(col, expr string) *Builder {
	b.setClauses = append(b.setClauses, col+" = "+expr)
	return b
}

/*
Where FIX (non-breaking)

Rules:
- If query has NO '?', arg is ignored
- If arg is nil AND no '?', do NOT bind
- If arg is slice AND query has '(?)', auto-expand
*/
func (b *Builder) Where(query string, arg any) *Builder {
	// Fast path: no placeholder â†’ expression only
	if !strings.Contains(query, "?") {
		b.where = append(b.where, query)
		return b
	}

	// Auto-expand IN (?)
	if slice, ok := arg.([]any); ok {
		if len(slice) == 0 {
			b.where = append(b.where, "1=0")
			return b
		}

		buf := make([]byte, 0, len(query)+len(slice)*3)
		for i := 0; i < len(query); i++ {
			if query[i] == '?' {
				for j := range slice {
					if j > 0 {
						buf = append(buf, ',', ' ')
					}
					buf = append(buf, byte('?'))
				}
			} else {
				buf = append(buf, query[i])
			}
		}

		b.where = append(b.where, string(buf))
		b.args = append(b.args, slice...)
		return b
	}

	// Normal single placeholder
	b.where = append(b.where, query)
	b.args = append(b.args, arg)
	return b
}

func (b *Builder) GroupBy(cols ...string) *Builder {
	b.groupBy = append(b.groupBy, cols...)
	return b
}

func (b *Builder) Having(query string, arg any) *Builder {
	// Same rules as Where
	if !strings.Contains(query, "?") {
		b.having = append(b.having, query)
		return b
	}

	// Auto-expand IN (?)
	if slice, ok := arg.([]any); ok {
		if len(slice) == 0 {
			b.having = append(b.having, "1=0")
			return b
		}

		buf := make([]byte, 0, len(query)+len(slice)*3)
		for i := 0; i < len(query); i++ {
			if query[i] == '?' {
				for j := range slice {
					if j > 0 {
						buf = append(buf, ',', ' ')
					}
					buf = append(buf, '?')
				}
			} else {
				buf = append(buf, query[i])
			}
		}

		b.having = append(b.having, string(buf))
		b.args = append(b.args, slice...)
		return b
	}

	b.having = append(b.having, query)
	b.args = append(b.args, arg)
	return b
}

func (b *Builder) OrderBy(order string) *Builder {
	b.order = order
	return b
}

func (b *Builder) Limit(limit int) *Builder {
	b.limit = limit
	return b
}

func (b *Builder) Offset(offset int) *Builder {
	b.offset = offset
	return b
}

func (b *Builder) Suffix(s string) *Builder {
	b.suffix = s
	return b
}

/* ---------- Finalizer ---------- */

func (b *Builder) ToSql() (string, []any, error) {
	bufPtr := bufferPool.Get().(*[]byte)
	buf := (*bufPtr)[:0]
	defer func() {
		*bufPtr = buf
		bufferPool.Put(bufPtr)
	}()

	paramIdx := 1

	write := func(s string) {
		for i := 0; i < len(s); i++ {
			if s[i] == '?' && b.isPostgres {
				if paramIdx <= 100 {
					buf = append(buf, postgresPlaceholders[paramIdx]...)
				} else {
					buf = append(buf, '$')
					buf = append(buf, strconv.Itoa(paramIdx)...)
				}
				paramIdx++
			} else {
				buf = append(buf, s[i])
			}
		}
	}

	switch b.mode {
	case modeSelect:
		write("SELECT ")
		if len(b.columns) == 0 {
			write("*")
		} else {
			for i, c := range b.columns {
				if i > 0 {
					write(", ")
				}
				write(c)
			}
		}
		write(" FROM ")
		write(b.table)
		for _, j := range b.joinClauses {
			write(" ")
			write(j)
		}

	case modeInsert:
		write("INSERT INTO ")
		write(b.table)
		write(" (")
		for i, c := range b.columns {
			if i > 0 {
				write(", ")
			}
			write(c)
		}
		write(") VALUES ")

		if b.isBatch {
			for i, row := range b.batchValues {
				if i > 0 {
					write(", ")
				}
				write("(")
				for j := 0; j < b.colCount; j++ {
					if j > 0 {
						write(", ")
					}
					write("?")
				}
				write(")")
				b.args = append(b.args, row...)
			}
		} else {
			write("(")
			for i := range b.values {
				if i > 0 {
					write(", ")
				}
				write("?")
			}
			write(")")
			b.args = append(b.args, b.values...)
		}

	case modeUpdate:
		write("UPDATE ")
		write(b.table)
		write(" SET ")
		for i, c := range b.setClauses {
			if i > 0 {
				write(", ")
			}
			write(c)
		}

	case modeDelete:
		write("DELETE FROM ")
		write(b.table)
	}

	if len(b.where) > 0 {
		write(" WHERE ")
		for i, w := range b.where {
			if i > 0 {
				write(" AND ")
			}
			write(w)
		}
	}

	if len(b.groupBy) > 0 {
		write(" GROUP BY ")
		for i, g := range b.groupBy {
			if i > 0 {
				write(", ")
			}
			write(g)
		}
	}

	if len(b.having) > 0 {
		write(" HAVING ")
		for i, h := range b.having {
			if i > 0 {
				write(" AND ")
			}
			write(h)
		}
	}

	if b.order != "" {
		write(" ORDER BY ")
		write(b.order)
	}

	if b.limit > 0 {
		write(" LIMIT ")
		buf = append(buf, strconv.Itoa(b.limit)...)
	}

	if b.offset > 0 {
		write(" OFFSET ")
		buf = append(buf, strconv.Itoa(b.offset)...)
	}

	if b.suffix != "" {
		write(" ")
		write(b.suffix)
	}

	sql := string(buf)
	return sql, b.args, nil
}

func (b *Builder) Release() {
	builderPool.Put(b)
}
