package database

import (
	"database/sql"
	"log"
	"os"
	"time"
	"fmt"
	"strings"
	sqldblogger "github.com/simukti/sqldb-logger"
	"github.com/simukti/sqldb-logger/logadapter/zapadapter"
	"github.com/go-sql-driver/mysql"
	"github.com/lib/pq"
	"github.com/mattn/go-sqlite3"
	gormMysql "gorm.io/driver/mysql"
	gormPostgres "gorm.io/driver/postgres"
	gormSqlite "gorm.io/driver/sqlite"
	"gorm.io/gorm"
	gormLog "gorm.io/gorm/logger"
	"{{.ProjectName}}/configs"
	"{{.ProjectName}}/logs"
	"gorm.io/plugin/opentelemetry/tracing"
)

func LoggerFile(app_name string) (*os.File, error) {
	log_file_name := fmt.Sprintf("%s_gorm.log", app_name)
	gormLogFile, gerr := os.OpenFile(log_file_name, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	if gerr != nil {
		log.Fatalf("error opening file: %v", gerr)
	}
	return gormLogFile, nil
}

func ReturnSession(app_name string, cfg *configs.EnvConfig, zapLogger *logs.Logger) (*gorm.DB, error) {
	env_name := fmt.Sprintf("%s_DB_TYPE", strings.ToUpper(app_name))
	app_env := cfg.Get(env_name)

	// GORM Internal Logger setup (for GORM specific events)
	gormFile, _ := LoggerFile(app_name)
	newLogger := gormLog.New(
		log.New(gormFile, "\r\n", log.LstdFlags),
		gormLog.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  gormLog.Info,
			Colorful:                  true,
			IgnoreRecordNotFoundError: true,
		},
	)

	var (
		DBSession *gorm.DB
		sqlDB     *sql.DB
		err       error
		adapter   = zapadapter.New(zapLogger.GetZapLogger()) // Use the raw *zap.Logger
	)

	// Universal switch for driver wrapping
	switch app_env {
	case "postgres":
		dsn := cfg.Get(fmt.Sprintf("%s_POSTGRES_URI", strings.ToUpper(app_name)))
		sqlDB = sqldblogger.OpenDriver(dsn, &pq.Driver{}, adapter)
		DBSession, err = gorm.Open(gormPostgres.New(gormPostgres.Config{
			Conn:                 sqlDB,
			PreferSimpleProtocol: true,
		}), &gorm.Config{Logger: newLogger, SkipDefaultTransaction: true})

	case "mysql":
		dsn := cfg.Get(fmt.Sprintf("%s_MYSQL_URI", strings.ToUpper(app_name)))
		sqlDB = sqldblogger.OpenDriver(dsn, &mysql.MySQLDriver{}, adapter)
		DBSession, err = gorm.Open(gormMysql.New(gormMysql.Config{
			Conn: sqlDB,
		}), &gorm.Config{Logger: newLogger, SkipDefaultTransaction: true})

	case "sqlite":
		dsn := cfg.Get(fmt.Sprintf("%s_SQLLITE_URI", strings.ToUpper(app_name)))
		sqlDB = sqldblogger.OpenDriver(dsn, &sqlite3.SQLiteDriver{}, adapter)
		DBSession, err = gorm.Open(gormSqlite.New(gormSqlite.Config{
			Conn: sqlDB,
		}), &gorm.Config{Logger: newLogger, SkipDefaultTransaction: true})

	default:
		return nil, fmt.Errorf("database type %s not supported", app_env)
	}

	if err != nil {
		return nil, err
	}

	// Apply Pool Settings to the wrapped sqlDB
	if app_env == "sqlite" {
		sqlDB.SetMaxOpenConns(1)
		sqlDB.SetConnMaxLifetime(5 * time.Second)
	} else {
		sqlDB.SetMaxOpenConns(100)
		sqlDB.SetMaxIdleConns(20)
		sqlDB.SetConnMaxLifetime(30 * time.Minute)
	}

	_ = DBSession.Use(tracing.NewPlugin())
	return DBSession, nil
}

