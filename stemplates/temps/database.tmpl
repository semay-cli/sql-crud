package database

import (
	"database/sql"
	"fmt"
	"log"
	"os"
	"net"
	"strings"
	"context"
	"strconv"
	"time"

	"{{ .ProjectName }}/configs"
	"{{ .ProjectName }}/logs" // Import your Zap logger package
	"github.com/go-sql-driver/mysql"
	"github.com/jackc/pgx/v5/stdlib"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	
	"github.com/mattn/go-sqlite3"
	sqldblogger "github.com/simukti/sqldb-logger"
	"github.com/simukti/sqldb-logger/logadapter/zapadapter"
	gormMysql "gorm.io/driver/mysql"
	gormPostgres "gorm.io/driver/postgres"
	gormSqlite "gorm.io/driver/sqlite"
	"gorm.io/gorm"
	gormLog "gorm.io/gorm/logger"
	"gorm.io/plugin/opentelemetry/tracing"
)

type DBBundle struct {
    Gorm *gorm.DB
    SQL  *sql.DB
    PGX  *pgxpool.Pool // only set for postgres
}


func LoggerFile(app_name string) (*os.File, error) {
	log_file_name := app_name + "_gorm.log"
	return os.OpenFile(log_file_name, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
}

func ReturnSession(app_name string, cfg *configs.EnvConfig, zapLogger *logs.Logger) (*DBBundle, error) {
	env_name := strings.ToUpper(app_name) + "_DB_TYPE"
	app_env := cfg.Get(env_name)

	// Check if we should use the expensive logger wrapper
	// Set DEBUG_SQL=true in your .env or export it to enable
	debugSQL := cfg.Get("DEBUG_SQL") == "true"

	// GORM Internal Logger setup
	gormFile, _ := LoggerFile(app_name)
	newLogger := gormLog.New(
		log.New(gormFile, "\r\n", log.LstdFlags),
		gormLog.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  gormLog.Error, // Keep at Error for high perf
			Colorful:                  true,
			IgnoreRecordNotFoundError: true,
		},
	)

	var (
		DBSession *gorm.DB
		sqlDB     *sql.DB
		err       error
		nativePool *pgxpool.Pool
	)

	// Universal switch for all three databases
	switch app_env {
	case "postgres":
		dsn := cfg.Get(strings.ToUpper(app_name) + "_POSTGRES_URI")

		// Create the Native PGX Pool
		poolConfig, err := pgxpool.ParseConfig(dsn)
		if err != nil {
			return nil, err
		}
		dialer := &net.Dialer{
			KeepAlive: 5 * time.Minute, // Sends TCP keep-alive probes
			Timeout:   5 * time.Second,
		}
		poolConfig.ConnConfig.DialFunc = dialer.DialContext
		
		// Pool size: env PG_POOL_MAX_CONNS / PG_POOL_MIN_CONNS (defaults 100/89 for throughput).
		// With prefork, total conns = numProcesses Ã— MaxConns; keep PgBouncer max_connections in mind.
		poolConfig.MaxConns = 100
		if v := cfg.Get("PG_POOL_MAX_CONNS"); v != "" {
			if n, err := strconv.Atoi(strings.TrimSpace(v)); err == nil && n > 0 {
				poolConfig.MaxConns = int32(n)
			}
		}
		poolConfig.MinConns = 89
		if v := cfg.Get("PG_POOL_MIN_CONNS"); v != "" {
			if n, err := strconv.Atoi(strings.TrimSpace(v)); err == nil && n > 0 && n <= int(poolConfig.MaxConns) {
				poolConfig.MinConns = int32(n)
			}
		}
		poolConfig.MaxConnIdleTime = 5 * time.Minute

		// PgBouncer (transaction/statement mode) does not preserve server-side prepared
		usePgBouncer := strings.EqualFold(strings.TrimSpace(cfg.Get("PG_BOUNCER")), "true")
		if usePgBouncer {
			poolConfig.ConnConfig.DefaultQueryExecMode = pgx.QueryExecModeSimpleProtocol
		}

		// Only attach query tracer when explicitly enabled (TRACE_SQL_QUERIES=true).
		// Avoids ~325MB alloc under load from TraceQueryStart when DEBUG_SQL is on.
		traceSQLQueries := strings.EqualFold(strings.TrimSpace(cfg.Get("TRACE_SQL_QUERIES")), "true")
		if debugSQL && traceSQLQueries {
			poolConfig.ConnConfig.Tracer = zapLogger
		}

		nativePool, err = pgxpool.NewWithConfig(context.Background(), poolConfig)
		if err != nil {
			return nil, err
		}

		// Now, derive the sql.DB for GORM from the pool to share connections
		sqlDB = stdlib.OpenDBFromPool(nativePool)

		DBSession, err = gorm.Open(gormPostgres.New(gormPostgres.Config{
			Conn:                 sqlDB,
			PreferSimpleProtocol: usePgBouncer, // must match pgx when behind PgBouncer
		}), &gorm.Config{Logger: newLogger, SkipDefaultTransaction: true, PrepareStmt: false})	

	case "mysql":
		dsn := cfg.Get(strings.ToUpper(app_name) + "_MYSQL_URI")

		if debugSQL {
			adapter := zapadapter.New(zapLogger.GetZapLogger())
			sqlDB = sqldblogger.OpenDriver(dsn, &mysql.MySQLDriver{}, adapter)
		} else {
			// HIGH PERFORMANCE MODE: Direct open
			sqlDB, err = sql.Open("mysql", dsn)
		}

		if err == nil {
			DBSession, err = gorm.Open(gormMysql.New(gormMysql.Config{
				Conn: sqlDB,
			}), &gorm.Config{Logger: newLogger, SkipDefaultTransaction: true})
		}

	case "sqlite":
		dsn := cfg.Get(strings.ToUpper(app_name) + "_SQLLITE_URI")

		if debugSQL {
			adapter := zapadapter.New(zapLogger.GetZapLogger())
			sqlDB = sqldblogger.OpenDriver(dsn, &sqlite3.SQLiteDriver{}, adapter)
		} else {
			// HIGH PERFORMANCE MODE: Direct open
			sqlDB, err = sql.Open("sqlite3", dsn)
		}

		if err == nil {
			DBSession, err = gorm.Open(gormSqlite.New(gormSqlite.Config{
				Conn: sqlDB,
			}), &gorm.Config{Logger: newLogger, SkipDefaultTransaction: true})
		}

	default:
		return nil, fmt.Errorf("database type %s not supported", app_env)
	}

	if err != nil {
		return nil, err
	}

		switch app_env {
		case "sqlite":
			sqlDB.SetMaxOpenConns(1)
			sqlDB.SetConnMaxLifetime(5 * time.Second)
		case "mysql":
			sqlDB.SetMaxOpenConns(200)
			sqlDB.SetMaxIdleConns(100)
			sqlDB.SetConnMaxLifetime(10 * time.Minute)
		default:

		}
	_ = DBSession.Use(tracing.NewPlugin())
	
	return &DBBundle{
		Gorm: DBSession,
		SQL:  sqlDB,
		PGX:  nativePool,
	}, nil
}
