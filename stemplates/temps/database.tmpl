package database

import (
	"database/sql"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"{{ .ProjectName }}/configs"
	"{{ .ProjectName }}/logs" // Import your Zap logger package
	"github.com/go-sql-driver/mysql"
	"github.com/jackc/pgx/v5/stdlib"

	// "github.com/lib/pq"

	"github.com/mattn/go-sqlite3"
	sqldblogger "github.com/simukti/sqldb-logger"
	"github.com/simukti/sqldb-logger/logadapter/zapadapter"
	gormMysql "gorm.io/driver/mysql"
	gormPostgres "gorm.io/driver/postgres"
	gormSqlite "gorm.io/driver/sqlite"
	"gorm.io/gorm"
	gormLog "gorm.io/gorm/logger"
	"gorm.io/plugin/opentelemetry/tracing"
)

func LoggerFile(app_name string) (*os.File, error) {
	log_file_name := app_name + "_gorm.log"
	return os.OpenFile(log_file_name, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
}

func ReturnSession(app_name string, cfg *configs.EnvConfig, zapLogger *logs.Logger) (*gorm.DB, error) {
	env_name := strings.ToUpper(app_name) + "_DB_TYPE"
	app_env := cfg.Get(env_name)

	// Check if we should use the expensive logger wrapper
	// Set DEBUG_SQL=true in your .env or export it to enable
	debugSQL := cfg.Get("DEBUG_SQL") == "true"

	// GORM Internal Logger setup
	gormFile, _ := LoggerFile(app_name)
	newLogger := gormLog.New(
		log.New(gormFile, "\r\n", log.LstdFlags),
		gormLog.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  gormLog.Error, // Keep at Error for high perf
			Colorful:                  true,
			IgnoreRecordNotFoundError: true,
		},
	)

	var (
		DBSession *gorm.DB
		sqlDB     *sql.DB
		err       error
	)

	// Universal switch for all three databases
	switch app_env {
	case "postgres":
		dsn := cfg.Get(strings.ToUpper(app_name) + "_POSTGRES_URI")

		if debugSQL {
			adapter := zapadapter.New(zapLogger.GetZapLogger())
			// Pass stdlib.GetDefaultDriver() for pgx
			sqlDB = sqldblogger.OpenDriver(dsn, stdlib.GetDefaultDriver(), adapter)
		} else {
			// HIGH PERFORMANCE MODE: Direct open
			sqlDB, err = sql.Open("pgx", dsn)
		}

		if err == nil {
			DBSession, err = gorm.Open(gormPostgres.New(gormPostgres.Config{
				Conn:                 sqlDB,
				PreferSimpleProtocol: true,
			}), &gorm.Config{Logger: newLogger, SkipDefaultTransaction: true})
		}

	case "mysql":
		dsn := cfg.Get(strings.ToUpper(app_name) + "_MYSQL_URI")

		if debugSQL {
			adapter := zapadapter.New(zapLogger.GetZapLogger())
			sqlDB = sqldblogger.OpenDriver(dsn, &mysql.MySQLDriver{}, adapter)
		} else {
			// HIGH PERFORMANCE MODE: Direct open
			sqlDB, err = sql.Open("mysql", dsn)
		}

		if err == nil {
			DBSession, err = gorm.Open(gormMysql.New(gormMysql.Config{
				Conn: sqlDB,
			}), &gorm.Config{Logger: newLogger, SkipDefaultTransaction: true})
		}

	case "sqlite":
		dsn := cfg.Get(strings.ToUpper(app_name) + "_SQLLITE_URI")

		if debugSQL {
			adapter := zapadapter.New(zapLogger.GetZapLogger())
			sqlDB = sqldblogger.OpenDriver(dsn, &sqlite3.SQLiteDriver{}, adapter)
		} else {
			// HIGH PERFORMANCE MODE: Direct open
			sqlDB, err = sql.Open("sqlite3", dsn)
		}

		if err == nil {
			DBSession, err = gorm.Open(gormSqlite.New(gormSqlite.Config{
				Conn: sqlDB,
			}), &gorm.Config{Logger: newLogger, SkipDefaultTransaction: true})
		}

	default:
		return nil, fmt.Errorf("database type %s not supported", app_env)
	}

	if err != nil {
		return nil, err
	}

	// Apply Pool Settings
	if app_env == "sqlite" {
		sqlDB.SetMaxOpenConns(1)
		sqlDB.SetConnMaxLifetime(5 * time.Second)
	} else {
		sqlDB.SetMaxOpenConns(100)
		sqlDB.SetMaxIdleConns(80)
		sqlDB.SetConnMaxLifetime(30 * time.Minute)
	}

	_ = DBSession.Use(tracing.NewPlugin())
	return DBSession, nil
}
