
package manager

import (
	"bytes"
	"io"
	"net/http"
	//"io/ioutil"
	"time"

	"github.com/labstack/echo/v4"
	//"go.uber.org/zap"
	"{{.ProjectName}}/logs"
	"{{.ProjectName}}/pools"

)


const maxLogSize = 1024 // maximum bytes to log for request/response

// truncate safely shortens the content to max bytes
func truncate(b []byte, max int) string {
	if len(b) <= max {
		return string(b)
	}
	return string(b[:max]) + "...(truncated)"
}

// bodyWriter wraps http.ResponseWriter to capture response body
type bodyWriter struct {
	io.Writer
	http.ResponseWriter
	body *bytes.Buffer
}

func (w *bodyWriter) Write(b []byte) (int, error) {
	w.body.Write(b) // capture
	return w.ResponseWriter.Write(b)
}

func ZapRequestLogger(l *logs.Logger) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			start := time.Now()
			err := next(c)

			// 1. Get the underlying zap.Logger
			z := l.GetZapLogger()
			req := c.Request()
			res := c.Response()

			if err != nil {
				// We always log errors, so no need for the Check guard here
				l.ErrorS("request_error",
					zap.String("method", req.Method),
					zap.String("uri", req.RequestURI),
					zap.Int("status", res.Status),
					zap.Duration("latency", time.Since(start)),
					zap.Error(err),
				)
				return err
			}

			// 2. SUCCESS PATH: Use z.Check to stop the "48GB Allocation"
			// This checks if the Sampler will actually write the log.
			// If it won't, it returns nil and skips the zap.Fields below.
			if ce := z.Check(zap.InfoLevel, "request"); ce != nil {
				ce.Write(
					zap.String("method", req.Method),
					zap.String("uri", req.RequestURI),
					zap.Int("status", res.Status),
					zap.Int64("size", res.Size),
					zap.Duration("latency", time.Since(start)),
				)
			}

			return nil
		}
	}
}