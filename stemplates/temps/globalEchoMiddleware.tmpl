
package manager

import (
	"sync"

	"{{.ProjectName}}/observe"
	"github.com/labstack/echo/v4"
	oteltrace "go.opentelemetry.io/otel/trace"
)

var AppRouteNames map[string]string

func MountGlobalMiddleware(app *echo.Echo) {

}

// Create a pool for your RouteTracer wrapper
var tracerPool = sync.Pool{
	New: func() any {
		return &observe.RouteTracer{}
	},
}

func NewOTelEchoSpanStarter(appTracer oteltrace.Tracer) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(ctx echo.Context) error {
			// 1. Path lookup is fine, but handle the "unnamed" case with a constant
			spanName := ctx.Path()
			if spanName == "" {
				spanName = "unnamed-route"
			}

			// 2. Start the span. Note: appTracer.Start is already optimized internally.
			traceCtx, span := appTracer.Start(ctx.Request().Context(), spanName)

			// 3. Acquire tracer from pool
			rt := tracerPool.Get().(*observe.RouteTracer)
			rt.Tracer = traceCtx
			rt.Span = span

			// 4. CRITICAL FIX: Avoid ctx.Set("tracer", rt)
			// Instead of putting it in the Echo Map (which allocates),
			// wrap the Request with the new trace context directly.
			req := ctx.Request()
			ctx.SetRequest(req.WithContext(traceCtx))

			err := next(ctx)

			// 5. Cleanup
			span.End()

			rt.Tracer = nil
			rt.Span = nil
			tracerPool.Put(rt)

			return err
		}
	}
}

// 1. Define this once in your manager or observe package
type AppContext struct {
	echo.Context
	Tracer *observe.RouteTracer
}

// 1. Create a pool for the AppContext wrapper
var appContextPool = sync.Pool{
	New: func() any {
		return &AppContext{}
	},
}

func FullChainMiddleware(appTracer oteltrace.Tracer) echo.MiddlewareFunc {
	// Define constants for values used in headers to avoid runtime string creation
	const (
		hdrAllowOrigin  = "Access-Control-Allow-Origin"
		hdrAllowMethods = "Access-Control-Allow-Methods"
		hdrAllowHeaders = "Access-Control-Allow-Headers"
		hdrMaxAge       = "Access-Control-Max-Age"
		hdrAppToken     = "X-App-Token"
		hdrRouteName    = "Route-Name"
		valMethods      = "GET, POST, PUT, DELETE, PATCH, OPTIONS"
		valMaxAge       = "86400"
		valNotSet       = "not-set"
	)

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			path := c.Path()

			// 2. CHECK BYPASS FIRST
			// Do this before any allocations or pool fetches to save CPU
			if path == "/api/v1/blue_auth/login" || path == "/api/v1/blue_auth/stats" {
				return next(c)
			}

			req := c.Request()
			resHdr := c.Response().Header()

			// 3. RECYCLE: Borrow AppContext from pool
			ac := appContextPool.Get().(*AppContext)
			ac.Context = c

			// 4. PREPARE CLEANUP
			// We use a manual cleanup at the end or defer.
			// In high-load, manual is slightly faster than defer.

			// 5. CORS - Direct Header Manipulation
			// Using .Set() is more optimized than map assignment for the net/http package
			resHdr.Set(hdrAllowOrigin, "*")
			resHdr.Set(hdrAllowMethods, valMethods)
			resHdr.Set(hdrAllowHeaders, "*")
			resHdr.Set(hdrMaxAge, valMaxAge)

			if req.Method == "OPTIONS" {
				// Return ac to pool before exiting
				ac.Context = nil
				appContextPool.Put(ac)
				return c.NoContent(204)
			}

			// 6. OTel START
			spanName := path
			if spanName == "" {
				spanName = "unnamed-route"
			}

			traceCtx, span := appTracer.Start(req.Context(), spanName)

			rt := tracerPool.Get().(*observe.RouteTracer)
			rt.Tracer = traceCtx
			rt.Span = span
			ac.Tracer = rt

			// 7. REQUEST HEADERS
			// Only set if not already present
			if req.Header.Get(hdrAppToken) == "" {
				req.Header.Set(hdrAppToken, "login")
			}

			routeName := valNotSet
			if name, exists := AppRouteNames[path]; exists {
				routeName = name
			}
			req.Header.Set(hdrRouteName, routeName)

			// 8. EXECUTE NEXT
			err := next(ac)

			// 9. FINAL CLEANUP (Manual return to pool)
			span.End()

			// Clear RouteTracer and return to pool
			rt.Tracer = nil
			rt.Span = nil
			tracerPool.Put(rt)

			// Clear AppContext and return to pool
			ac.Context = nil
			ac.Tracer = nil
			appContextPool.Put(ac)

			return err
		}
	}
}
