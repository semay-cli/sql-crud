
package manager

import (
	"fmt"
	"{{.ProjectName}}/observe"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"strings"
	"go.opentelemetry.io/otel/attribute"
	oteltrace "go.opentelemetry.io/otel/trace"
)
var AppRouteNames map[string]string

func GetApplicationRoutes(app *echo.Echo) {
	// Lock the Mutex to ensure safe access to AppRouteNames

	AppRouteNames = make(map[string]string)
	for _, route := range app.Routes() {
		routeName := route.Name
		if route.Name == "" {
			// Skip routes without a name
			continue
		}
		AppRouteNames[route.Path] = routeName
	}
}

// SetRouteName header based on path
func SetRouteNameHeader(next echo.HandlerFunc) echo.HandlerFunc {
	return func(contx echo.Context) error {

		routeName, exists := AppRouteNames[contx.Path()]

		// If the route name doesn't exist in the map, set it to "not-set"
		if !exists {
			routeName = "not-set"
		}

		// If the x-app-token header is missing, set a default value
		contx.Request().Header.Set("route-name", routeName)

		// Continue processing the request
		return next(contx)
	}
}

func NextAuthValidator(key string, ctx echo.Context) (bool, error) {

	if ctx.Path() == "/api/v1/blue_auth/login" || ctx.Path() == "/api/v1/blue_auth/stats" {
		return true, nil
	}
    ctx.Logger().Info("Path: ", ctx.Path())
    // ctx.Logger().Info("Key: ", key)

	//  You have to fix the NextAuthValidator function, it will let all values pass
	// using required role access logic
	return true, nil
}

// AddAppTokenIfMissing is a middleware that checks if the x-app-token header is present in the request. so that the login route can work
func AddAppTokenIfMissing(next echo.HandlerFunc) echo.HandlerFunc {
	return func(contx echo.Context) error {
		// Check if x-app-token header exists
		appToken := contx.Request().Header.Get("x-app-token")

		// If the x-app-token header is missing, set a default value
		if appToken == "" {
			contx.Request().Header.Set("x-app-token", "login")
		}

		// Continue processing the request
		return next(contx)
	}
}

func MountGlobalMiddleware(app *echo.Echo) {
	// Mount the middleware
	app.Use(SetRouteNameHeader)
	app.Use(AddAppTokenIfMissing)
	app.Use(middleware.KeyAuthWithConfig(middleware.KeyAuthConfig{
		KeyLookup: "header:x-app-token",
		Validator: NextAuthValidator,
	}))

}

func NewOTelEchoSpanStarter(appTracer oteltrace.Tracer) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(ctx echo.Context) error {
			routeName := ctx.Path() + "_" + strings.ToLower(ctx.Request().Method)
			trace, span := observe.EchoAppSpanner(ctx, fmt.Sprintf("%v-root", routeName), appTracer)
			ctx.Set("tracer", &observe.RouteTracer{Tracer: trace, Span: span})

			err := next(ctx)
			if err != nil {
				return err
			}

			status := ctx.Response().Status
			if status >= 400 {
				span.SetAttributes(attribute.String("response", fmt.Sprintf("%v", status)))
				span.RecordError(fmt.Errorf("HTTP error: %d", status))
			}
			span.End()
			return nil
		}
	}
}
