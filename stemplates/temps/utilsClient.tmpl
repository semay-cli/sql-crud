package utils

import (
	"bytes"
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"

	"{{.ProjectName}}/configs"
	"github.com/hashicorp/go-retryablehttp"
	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
)
type ApiClient struct {
	Client *http.Client
}

func NewApiClient(cfg configs.Config) *ApiClient {
	// 1. Get Configs
	timeoutStr := cfg.GetOrDefault("HTTP_TIMEOUT", "30s")
	timeout, _ := time.ParseDuration(timeoutStr)
	verifySSLStr := cfg.GetOrDefault("HTTP_SSL_VERIFY", "true")
	verifySSL, _ := strconv.ParseBool(verifySSLStr)

	// 2. Configure Retry Logic (Exponential Backoff + Jitter)
	retryClient := retryablehttp.NewClient()
	retryClient.RetryMax = 5                       // Max 5 retries (6 attempts total)
	retryClient.RetryWaitMin = 1 * time.Second     // Minimum wait time
	retryClient.RetryWaitMax = 30 * time.Second    // Maximum wait time cap
	retryClient.Backoff = retryablehttp.DefaultBackoff // Built-in Exponential + Jitter
	retryClient.Logger = nil                       // Silence internal retry logs (or use your own)

	// 3. Configure Transport (SSL + OTel Propagation)
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: !verifySSL},
	}
	
	// Wrap transport with OpenTelemetry instrumentation
	otelTr := otelhttp.NewTransport(tr)

	// 4. Merge into a standard *http.Client
	// StandardClient() converts retryable logic into a standard Go http.Client
	standardClient := retryClient.StandardClient()
	standardClient.Transport = otelTr
	standardClient.Timeout = timeout

	return &ApiClient{Client: standardClient}
}

// Send makes a generic HTTP request with retries, tracing, and context support.
func (c *ApiClient) Send(ctx context.Context, method, url string, headers map[string]string, body any, result any) error {
	var bodyReader io.Reader
	isRawReader := false

	// Prepare Body
	if body != nil {
		switch v := body.(type) {
		case io.Reader:
			bodyReader = v
			isRawReader = true
		default:
			jsonBody, err := json.Marshal(body)
			if err != nil {
				return fmt.Errorf("failed to marshal body: %w", err)
			}
			bodyReader = bytes.NewBuffer(jsonBody)
		}
	}

	// Create Request with Context for OTel and Cancellation
	req, err := http.NewRequestWithContext(ctx, method, url, bodyReader)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	// Set Default Content-Type for JSON
	if body != nil && !isRawReader {
		req.Header.Set("Content-Type", "application/json")
	}

	// Apply custom headers (can override defaults)
	for k, v := range headers {
		req.Header.Set(k, v)
	}

	// Execute Request (this call now handles the 5 retries + jitter internally)
	resp, err := c.Client.Do(req)
	if err != nil {
		return fmt.Errorf("request failed after retries: %w", err)
	}
	defer resp.Body.Close()

	// Error handling for unsuccessful status codes
	if resp.StatusCode >= 400 {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("api error: status %d, body: %s", resp.StatusCode, string(bodyBytes))
	}

	// Unmarshal result if provided
	if result != nil && resp.StatusCode != http.StatusNoContent {
		if err := json.NewDecoder(resp.Body).Decode(result); err != nil {
			return fmt.Errorf("failed to decode response: %w", err)
		}
	}

	return nil
}