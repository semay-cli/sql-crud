package manager

import (
	"context"
	"fmt"
	"strconv"
	"time"


	{{- range .AppNames}}
	{{ . | replaceString }}"{{$.ProjectName}}/{{ . }}"
	{{ . | replaceString }}_repo "{{$.ProjectName}}/{{ . }}/repository"
	{{ . | replaceString }}_svc "{{$.ProjectName}}/{{ . }}/services"
	{{ . | replaceString }}_ctrl "{{$.ProjectName}}/{{ . }}/controllers"
	{{- end }}

	"{{.ProjectName}}/cache"
	"{{.ProjectName}}/configs"
	"{{.ProjectName}}/logs"
	"{{.ProjectName}}/crons"
	"{{.ProjectName}}/database"
	"{{.ProjectName}}/observe"

	echoSwagger "github.com/bushubdegefu/echo-swagger"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/labstack/gommon/log"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/robfig/cron/v3"
	"github.com/spf13/cobra"
	oteltrace "go.opentelemetry.io/otel/trace"
	"go.uber.org/dig"
	"golang.org/x/time/rate"
	"gorm.io/gorm"
)

var (
	app_otel string
	app_tls  string

	echocli = &cobra.Command{
		Use:   "run",
		Short: "Run Development server",
		Long:  "Run development server",
		Run: func(cmd *cobra.Command, args []string) {
			isWorker := false
			for _, arg := range args {
				if arg == "worker" {
					isWorker = true
					break
				}
			}

			container := buildContainer()
			err := container.Invoke(func(deps struct {
				dig.In
				App                *echo.Echo
				Cfg                *configs.EnvConfig
				Logger             *logs.Logger
				{{- range .AppNames}}
				{{ . | toPascalCase }}Ctrl      *{{ . | replaceString }}_ctrl.{{ . | toPascalCase }}Controller           `name:"{{ . | replaceString }}_controller"`

				{{- end}}
				Scheduler          *crons.ScheduledService
			}) {
				// Register routes with their respective controllers
				{{- range .AppNames}}
				{{ . | replaceString }}.SetupRoutes(deps.App, deps.{{ . | toPascalCase }}Ctrl)
				{{- end}}

				if isWorker {
					deps.Logger.Info(fmt.Sprintf("Worker PID %d starting Echo...", os.Getpid()))
					port := deps.Cfg.Get("HTTP_PORT")
					addr := "0.0.0.0:" + port
					runWorker(deps.App, addr, deps.Logger)
				} else {
					// MASTER: Start the scheduler and spawn workers
					deps.Scheduler.Start()
					startMaster(deps.Logger)
				}

				defer deps.Logger.Sync()
			})
			if err != nil {
				log.Fatalf("Error starting application: %v", err)
			}
		},
	}
)



// ---- Echo Setup ----

func NewEchoApp(cfg *configs.EnvConfig, logger *logs.Logger, appTracer oteltrace.Tracer, prom *prometheus.Registry) *echo.Echo {
	app := echo.New()

	// pooled json serilizers
	app.JSONSerializer = NewPooledJSONSerializer()

	app.Logger = logger

	app.Use(middleware.Recover())
	app.Use(FullChainMiddleware(appTracer))


    // Zap logging mouter
    app.Use(ZapRequestLogger(logger))

	// ðŸ‘‡ Custom OpenTelemetry middleware
	app.Use(NewOTelEchoSpanStarter(appTracer))
	observe.SetupPrometheusMetrics(app, cfg)
	//app.Use(observe.PrometheusMiddleware(cfg.Get("APP_NAME")))

	// Rate limit middleware
	configLimit, _ := strconv.ParseFloat(cfg.GetOrDefault("RATE_LIMIT_PER_SECOND", "50000"), 64)
	app.Use(middleware.RateLimiter(middleware.NewRateLimiterMemoryStore(rate.Limit(configLimit))))

	app.Use(middleware.RecoverWithConfig(middleware.RecoverConfig{
		StackSize: 1 << 10,
		LogLevel:  log.ERROR,
	}))

	MountGlobalMiddleware(app)

		{{- if eq .AuthAppType  "sso" }}
	// Serve static files from the "dist/django_admin_ui" folder
	app.Static("/adm/", "./dist/sso_admin_ui")

	// Handle "/admin/*" route and send the "index.html" file
	app.GET("/admin/*", func(c echo.Context) error {
		return c.File("./dist/sso_admin_ui/index.html")
	}).Name = "Admin_UI"

	{{- end }}

    // OpenAPI documentation
	{{- range .AppNames}}
	//  {{ . }} Swagger Docs
	app.GET("/{{ . | replaceString }}/docs/doc.json", func(contx echo.Context) error {
			return contx.File("{{ . }}/docs/swagger.json")
		}).Name = "{{ . | replaceString}}_docs_json"

	app.GET("/{{ . | replaceString}}/docs/*", echoSwagger.New(echoSwagger.Config{
		InstanceName: "{{ . | replaceString}}",
		URL:          "/{{ . | replaceString }}/docs/doc.json", // Match the served JSON file
	})).Name = "{{ . | replaceString}}_docs"
	{{- end }}


	// /metrics route
	observe.InitProm(prom, cfg)
	observe.RegisterPrometheusEndpoint(app, prom)

	// blue_admin.SetupRoutes(app)
	// shipping_portal.SetupRoutes(app)

	return app
}

func startMaster(logger *logs.Logger) {
	numCPU := runtime.NumCPU()
	logger.Info(fmt.Sprintf("Master PID %d managing %d workers", os.Getpid(), numCPU))

	processes := make(map[int]*os.Process)
	var mu sync.Mutex

	// Function to spawn a worker
	spawn := func() {
		cmd := os.Args[0]
		// Explicitly pass "worker" as the command argument

		args := []string{cmd, "run", "worker"}
		proc, err := os.StartProcess(cmd, args, &os.ProcAttr{
			Env:   os.Environ(),
			Files: []*os.File{os.Stdin, os.Stdout, os.Stderr},
		})
		// .
		if err != nil {
			logger.Error("Failed to start worker process: ", err)
			return
		}

		mu.Lock()
		processes[proc.Pid] = proc
		mu.Unlock()

		// Monitor this specific process
		go func(p *os.Process) {
			state, _ := p.Wait()

			mu.Lock()
			delete(processes, p.Pid)
			mu.Unlock()

			if state != nil && !state.Success() {
				logger.Warn(fmt.Sprintf("Worker %d exited with error, respawning...", p.Pid))
				time.Sleep(1 * time.Second) // Throttling
				// Note: Re-spawn logic would go here if you want high availability
			}
		}(proc)
	}

	// Initial Start
	for i := 0; i < numCPU; i++ {
		spawn()
	}

	// Correct Signal Handling for Ctrl+C
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	// This block is what allows Ctrl+C to work
	receivedSig := <-sigChan
	logger.Info(fmt.Sprintf("Master received signal: %v. Shutting down workers...", receivedSig))

	mu.Lock()
	for pid, proc := range processes {
		logger.Info(fmt.Sprintf("Sending SIGTERM to worker %d", pid))
		_ = proc.Signal(syscall.SIGTERM)
	}
	mu.Unlock()

	// Give workers time to finish gracefully
	time.Sleep(2 * time.Second)
	logger.Info("Master process exiting.")
	os.Exit(0)
}

// Worker function for prefork
func runWorker(app *echo.Echo, addr string, logger *logs.Logger) {
	host, portStr, _ := net.SplitHostPort(addr)
	port, _ := strconv.Atoi(portStr)

	// Create raw socket
	fd, err := unix.Socket(unix.AF_INET, unix.SOCK_STREAM|unix.SOCK_NONBLOCK|unix.SOCK_CLOEXEC, 0)
	if err != nil {
		logger.Fatal("Socket error:", err)
	}

	// Important: Close the raw FD once we've handed it off to net.Listener
	defer unix.Close(fd)

	_ = unix.SetsockoptInt(fd, unix.SOL_SOCKET, unix.SO_REUSEADDR, 1)
	if err := unix.SetsockoptInt(fd, unix.SOL_SOCKET, unix.SO_REUSEPORT, 1); err != nil {
		logger.Fatal("SO_REUSEPORT not supported:", err)
	}

	sa := &unix.SockaddrInet4{Port: port}
	copy(sa.Addr[:], net.ParseIP(host).To4())
	if err := unix.Bind(fd, sa); err != nil {
		logger.Fatal("Bind error:", err)
	}

	if err := unix.Listen(fd, unix.SOMAXCONN); err != nil {
		logger.Fatal("Listen error:", err)
	}

	// Hand off to Go's net package
	file := os.NewFile(uintptr(fd), "listener")
	ln, err := net.FileListener(file)
	file.Close() // Safe to close after FileListener
	if err != nil {
		logger.Fatal("FileListener error:", err)
	}

	// Worker Graceful Shutdown
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-quit
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		_ = app.Shutdown(ctx)
	}()

	// Start Serving
	var serveErr error
	if app_tls == "on" {
		serveErr = app.Server.ServeTLS(ln, "./server.pem", "./server-key.pem")
	} else {
		serveErr = app.Server.Serve(ln)
	}

	if serveErr != nil && serveErr != http.ErrServerClosed {
		logger.Fatal("Worker server failed:", serveErr)
	}
}



// ---- Dependency Injection Container ----

func buildContainer() *dig.Container {
	container := dig.New()

	mustProvide := func(err error) {
		if err != nil {
			panic(fmt.Errorf("dig provide failed: %w", err))
		}
	}

	// Provide configuration
	mustProvide(container.Provide(configs.NewEnvConfig))

	// zap Logger
	mustProvide(container.Provide(logs.NewZapLogger ))

	// Provide Cron engine
	container.Provide(func() *cron.Cron {
		return cron.New()
	})

	// Initialize otel Tracer
	mustProvide(container.Provide(observe.NewAppTracer))

	// Provide cache
	mustProvide(container.Provide(cache.NewCacheService))

	// Provide Prometheus Registry
	mustProvide(container.Provide(func() *prometheus.Registry {
		return prometheus.NewRegistry()
	}))

	{{ range .AppNames}}
	// Provide named DBs
	mustProvide(container.Provide(func(cfg *configs.EnvConfig,logger *logs.Logger) (*gorm.DB, error) {
		return database.ReturnSession("{{ . | replaceString }}", cfg, logger)
	}, dig.Name("{{ . | replaceString }}_db")))
	{{- end }}


	{{ range .AppNames}}

	// Provide {{ . | replaceString }} repository
	mustProvide(container.Provide(func(in struct {
		dig.In
		DB    *gorm.DB `name:"{{ . | replaceString }}_db"`
		Cache *cache.CacheService
		Cfg   *configs.EnvConfig
	}) *{{ . | replaceString }}_repo.{{ . | toPascalCase }}Repository  {
		return {{ . | replaceString }}_repo.InitRepository(in.DB, in.Cache, in.Cfg)
	}, dig.Name("{{ . | replaceString }}_repo")))

	{{- end }}


	{{ range .AppNames}}

    	// Provide {{ . | replaceString }} service
    	mustProvide(container.Provide(func(in struct {
    		dig.In
    		DB    *gorm.DB `name:"{{ . | replaceString }}_db"`
    		Cache *cache.CacheService
    		Cfg   *configs.EnvConfig
    		Repo  *{{ . | replaceString }}_repo.{{ . | toPascalCase }}Repository        `name:"{{ . | replaceString }}_repo"`
    	}) *{{ . | replaceString }}_svc.{{ . | toPascalCase }}Service  {
    		return {{ . | replaceString }}_svc.InitService(in.DB, in.Cache, in.Cfg,in.Repo)
    	}, dig.Name("{{ . | replaceString }}_svc")))

    	{{- end }}

	{{ range .AppNames}}

	// Provide controllers
	mustProvide(container.Provide(func(in struct {
		dig.In
		Svc *{{ . | replaceString }}_svc.{{ . | toPascalCase }}Service `name:"{{ . | replaceString }}_svc"`
	}) *{{ . | replaceString }}_ctrl.{{ . | toPascalCase }}Controller {
		return {{ . | replaceString }}_ctrl.New{{ . | toPascalCase }}Controller(in.Svc)
	}, dig.Name("{{ . | replaceString }}_controller")))
	{{- end }}

	//  Intitialize chron service
	mustProvide(container.Provide(func(in struct {
		dig.In
		Crn   *cron.Cron
		Cfg   *configs.EnvConfig
		{{- range .AppNames}}
		{{ . | toPascalCase }}Repo *{{ . | replaceString }}_repo.{{ . | toPascalCase }}Repository           `name:"{{ . | replaceString }}_repo"`
	{{- end }}
	}) *crons.ScheduledService {
		return crons.NewScheduledService(in.Crn, in.Cfg,
	{{- range .AppNames}}
		in.{{ . | toPascalCase }}Repo,
	{{- end }}
		)
	}))


	// Provide Echo app
	mustProvide(container.Provide(func(cfg *configs.EnvConfig,  appTracer oteltrace.Tracer, prom *prometheus.Registry, logger *logs.Logger) *echo.Echo {
		return NewEchoApp(cfg,logger ,appTracer, prom)
	}))

	return container
}

// ---- CLI Flags ----

func init() {
	echocli.Flags().StringVar(&app_otel, "otel", "off", "Enable OpenTelemetry tracing (on/off)")
	echocli.Flags().StringVar(&app_tls, "tls", "off", "Enable TLS (on/off)")
	goFrame.AddCommand(echocli)
}
