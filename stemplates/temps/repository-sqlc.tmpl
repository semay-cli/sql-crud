package repository

import (
    "context"
    "fmt"
    "database/sql"
    {{- $break_3 := false }}
    {{- range .Fields }}
        {{- if eq .Name "UUID" }}
            {{- $break_3 = true }}
        {{- end }}
    {{- end }}

    {{- if $break_3 }}
    "github.com/google/uuid"
    {{- end }}
    "{{ .ProjectName }}/{{ $.AppName }}/models"
    "{{ .ProjectName }}/querybuilder"
    "{{ .ProjectName }}/common"
    "github.com/jackc/pgx/v5"
)


// Create inserts a new {{.LowerName}}
func (s *{{ .AppName | toPascalCase }}Repository) Create{{.Name}}(ctx context.Context, posted_{{.LowerName}} *models.{{.Name}}Post, tx any, out *models.{{.Name}}) error {
    {{- range .Fields}} {{- if .Post}}
        {{- if eq .Name "Password" }}
    hashedPassword, _ := models.HashPassword(*posted_{{$.LowerName}}.Password)
        {{- end }}
    {{- end }}
    {{- if eq .Name "UUID" }}
    {{$.LowerName}}_uuid, _ := uuid.NewV7()
    {{- end }}
    {{- end }}

    {{- /* 1. SNOWFLAKE ID GENERATION */ -}}
    {{- if .SnowFlake }}
    newID := s.SnowFlake.GenerateShort()
    if newID <= 0 {
        return fmt.Errorf("invalid Snowflake ID generated: %d", newID)
    }
    {{- end }}

    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    qb.Insert("{{.Name | toSnakeCase }}s").
        Columns(
        {{- if .SnowFlake }}"id",{{- end }} {{- /* Add ID column if Snowflake */ -}}
        {{- $i := 0 -}}
        {{- range .Fields -}}
            {{- if and (or .Post (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") -}}
                {{- if gt $i 0}}, {{end}}"{{.Name | toSnakeCase}}"
                {{- $i = add $i 1 -}}
            {{- end -}}
        {{- end -}}
    ).
        Values(
        {{- if .SnowFlake }}newID,{{- end }} {{- /* Add ID value if Snowflake */ -}}
        {{- range .Fields}} {{- if .Post}}
            {{- if eq .Name "Password" }} hashedPassword,
            {{- else if eq .Name "UUID" }} {{$.LowerName}}_uuid.String(),
            {{- else if eq .Type "bool" }} *posted_{{$.LowerName}}.{{.Name}},
            {{- else }} posted_{{$.LowerName}}.{{.Name}},
            {{- end }}
        {{- end }}
        {{- if eq .Name "UUID" }} {{$.LowerName}}_uuid.String(), {{- end }}
        {{- end }}
    )

    qb.SetExpr("created_at", "CURRENT_TIMESTAMP").Suffix("RETURNING *")
    query, args, err := qb.ToSql()
    if err != nil { return err }

    row := s.execQueryRow(ctx, tx, query, args...)

    var item models.{{.Name}}
    err = row.Scan(
      {{- range .Fields}}{{- if ne .DBType "None"}} &item.{{.Name}}, {{- end }}{{- end }}
       &item.UpdatedAt, &item.CreatedAt,
    )
    if err != nil { return err }
    if out != nil { *out = item }
    return nil
}

// GetOne fetches a {{.LowerName}} by ID
func (s *{{ .AppName | toPascalCase }}Repository) GetOne{{.Name}}(ctx context.Context, id string, out *models.{{.Name}}) error {
    cacheKey := "{{.LowerName}}:" + id
    if cached, found := s.Cache.Get(cacheKey); found {
        *out = *(cached.(*models.{{.Name}}))
        return nil
    }

    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    qb.Select({{- range .Fields}}{{- if ne .DBType "None"}} "{{.Name | toSnakeCase }}", {{- end }}{{- end }}"created_at","updated_at").
        From("{{.Name | toSnakeCase }}s").
        Where("id = ?", id)
    query, args, _ := qb.ToSql()

    var err error
    if s.NativePool != nil {
        err = s.NativePool.QueryRow(ctx, query, args...).Scan(
            {{- range .Fields}}{{- if ne .DBType "None"}} &out.{{.Name}}, {{- end }}{{- end }}
            &out.UpdatedAt, &out.CreatedAt,
        )
    } else {
        err = s.SQLC.QueryRowContext(ctx, query, args...).Scan(
            {{- range .Fields}}{{- if ne .DBType "None"}} &out.{{.Name}}, {{- end }}{{- end }}
            &out.UpdatedAt, &out.CreatedAt,
        )
    }

    if err == nil { s.Cache.Set(cacheKey, out) }
    return err
}

{{ if gt (len .GetOneFields) 0 }}
{{ range $i, $field := .GetOneFields }}

// Get{{$.Name}}By{{ $field | getBase | toPascalCase }} fetches a {{$.LowerName}} by {{ $field | getBase }}
func (s *{{ $.AppName | toPascalCase }}Repository) Get{{$.Name}}By{{ $field | getBase | toPascalCase }}(ctx context.Context, {{ $field | toSnakeCase }} string, out *models.{{$.Name}}) error {
    // checking Cache if it exists
    cacheKey := "{{$.LowerName}}:" + {{ $field | toSnakeCase }}
    if cached, found := s.Cache.Get(cacheKey); found {
        *out = *(cached.(*models.{{$.Name}}))
        return nil
    }

    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    qb.Select({{- range $.Fields}}{{- if ne .DBType "None"}} "{{$.Name | toInitials}}.{{.Name | toSnakeCase }}", {{- end }}{{- end }}"{{$.Name | toInitials }}.created_at","{{$.Name | toInitials }}.updated_at").
        From("{{$.Name | toSnakeCase }}s {{$.Name | toInitials}}").
        Where("{{$.Name | toInitials}}.{{ $field | getBase }}= ?", {{ $field | toSnakeCase }})

    query, args, err := qb.ToSql()
    if err != nil {
        return fmt.Errorf("failed to build SQL: %v", err)
    }

    // NATIVE POOL BRANCH
    if s.NativePool != nil {
        err = s.NativePool.QueryRow(ctx, query, args...).Scan(
            {{- range $.Fields}}{{- if .Get }}
            &out.{{.Name}},
            {{- end }}{{- end }}
            &out.UpdatedAt,
            &out.CreatedAt,
        )
    } else {
        // FALLBACK BRANCH
        err = s.SQLC.QueryRowContext(ctx, query, args...).Scan(
            {{- range $.Fields}}{{- if .Get }}
            &out.{{.Name}},
            {{- end }}{{- end }}
            &out.UpdatedAt,
            &out.CreatedAt,
        )
    }

    if err != nil {
        return err
    }

    if out != nil {
        cachedCopy := *out
        s.Cache.Set(cacheKey, &cachedCopy)
    }

    return nil
}
{{ end }}{{- end }}

// Get{{.Name}}sByIDs fetches multiple {{.LowerName}} records by IDs
func (s *{{ .AppName | toPascalCase }}Repository) Get{{.Name}}sByIDs(
    ctx context.Context,
    ids []uint,
    out *[]models.{{.Name}}Get,
) error {

    if len(ids) == 0 {
        *out = []models.{{.Name}}Get{}
        return nil
    }

    isPG := s.DB.Dialector.Name() == "postgres"

    // ðŸš€ NATIVE POSTGRES OPTIMIZED PATH
    if s.NativePool != nil {
        query := `
            SELECT
                {{- range .Fields}}{{- if ne .DBType "None"}} {{.Name | toSnakeCase}}, {{- end }}{{- end }}
                created_at, updated_at
            FROM {{.Name | toSnakeCase}}s
            WHERE id = ANY($1)
        `

        rows, err := s.NativePool.Query(ctx, query, ids)
        if err != nil { return err }
        defer rows.Close()

        items := (*out)[:0]
        item := models.{{.Name}}GetItemPool.Get()
	    defer models.{{.Name}}GetItemPool.Put(item)

        for rows.Next() {

            err := rows.Scan(
                {{- range .Fields}}{{- if ne .DBType "None"}} &item.{{.Name}}, {{- end }}{{- end }}
                &item.CreatedAt,
                &item.UpdatedAt,
            )

            items = append(items, *item)
            if err != nil {
    			item.Reset()
    			return  err
    		}
    		item.Reset()
        }

        *out = items
        return rows.Err()
    }

    // ðŸ§± FALLBACK PATH
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    qb.Select(
        {{- range .Fields}}{{- if ne .DBType "None"}} "{{.Name | toSnakeCase}}", {{- end }}{{- end }}
        "created_at","updated_at",
    ).
        From("{{.Name | toSnakeCase}}s").
        Where("id IN (?)", ids)

    query, args, err := qb.ToSql()
    if err != nil { return err }

    rows, err := s.SQLC.QueryContext(ctx, query, args...)
    if err != nil { return err }
    defer rows.Close()

    items := (*out)[:0]
    item := models.{{.Name}}GetItemPool.Get()
	defer models.{{.Name}}GetItemPool.Put(item)

    for rows.Next() {

        err := rows.Scan(
            {{- range .Fields}}{{- if ne .DBType "None"}} &item.{{.Name}}, {{- end }}{{- end }}
            &item.CreatedAt,
            &item.UpdatedAt,
        )

        items = append(items, *item)
        if err != nil {
			item.Reset()
			return err
		}
		item.Reset()
    }

    *out = items
    return rows.Err()
}

{{ if gt (len .GetOneFields) 0 }}
{{ range $i, $field := .GetOneFields }}

// Get{{$.Name}}sBy{{ $field | getBase | toPascalCase }}s fetches multiple {{$.LowerName}} records by {{ $field | getBase }}
func (s *{{ $.AppName | toPascalCase }}Repository) Get{{$.Name}}sBy{{ $field | getBase | toPascalCase }}s(
    ctx context.Context,
    values []string,
    out *[]models.{{$.Name}}Get,
) error {

    if len(values) == 0 {
        *out = []models.{{$.Name}}Get{}
        return nil
    }

    isPG := s.DB.Dialector.Name() == "postgres"

    // =========================
    // ðŸš€ NATIVE POSTGRES PATH
    // =========================
    if s.NativePool != nil {

        query := `
            SELECT
                {{- range $.Fields}}{{- if ne .DBType "None"}}
                {{.Name | toSnakeCase}},
                {{- end}}{{- end}}
                created_at,
                updated_at
            FROM {{$.Name | toSnakeCase}}s
            WHERE {{ $field | getBase }} = ANY($1)
        `

        rows, err := s.NativePool.Query(ctx, query, values)
        if err != nil { return err }
        defer rows.Close()

        items := (*out)[:0]
        item := models.{{$.Name}}GetItemPool.Get()
	    defer models.{{$.Name}}GetItemPool.Put(item)

        for rows.Next() {

            err := rows.Scan(
                {{- range $.Fields}}{{- if ne .DBType "None"}}
                &item.{{.Name}},
                {{- end}}{{- end}}
                &item.CreatedAt,
                &item.UpdatedAt,
            )
            items = append(items, *item)
            if err != nil {
    			item.Reset()
    			return err
    		}
    		item.Reset()
        }

        *out = items
        return rows.Err()
    }

    // =========================
    // ðŸ§± FALLBACK PATH
    // =========================
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    qb.Select(
        {{- range $.Fields}}{{- if ne .DBType "None"}}
        "{{.Name | toSnakeCase}}",
        {{- end}}{{- end}}
        "created_at",
        "updated_at",
    ).
        From("{{$.Name | toSnakeCase}}s").
        Where("{{ $field | getBase }} IN (?)", values)

    query, args, err := qb.ToSql()
    if err != nil { return err }

    rows, err := s.SQLC.QueryContext(ctx, query, args...)
    if err != nil { return err }
    defer rows.Close()

    items := (*out)[:0]
    item := models.{{$.Name}}GetItemPool.Get()
	defer models.{{$.Name}}GetItemPool.Put(item)

    for rows.Next() {

        err := rows.Scan(
            {{- range $.Fields}}{{- if ne .DBType "None"}}
            &item.{{.Name}},
            {{- end}}{{- end}}
            &item.CreatedAt,
            &item.UpdatedAt,
        )
        items = append(items, *item)
        if err != nil {
			item.Reset()
			return err
		}
		item.Reset()
    }

    *out = items
    return rows.Err()
}

{{ end }}
{{ end }}


// Get{{.Name}}s returns resources with high-perf native pool branch
func (s *{{ .AppName | toPascalCase }}Repository) Get{{.Name}}s(ctx context.Context, pagination models.Pagination, searchTerm map[string]string, out *[]models.{{.Name}}Get) (uint, error) {
    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    qb.Select("{{.Name | toInitials}}.id",
    {{- $i := 0 -}}
    {{- range .Fields -}}
        {{- if and (or .Get (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") -}}
            {{- if gt $i 0}}, {{end}}"{{$.Name | toInitials}}.{{.Name | toSnakeCase}}"
            {{- $i = add $i 1 -}}
        {{- end -}}
    {{- end -}}, "count(*) OVER() as total_count").From("{{.Name | toSnakeCase}}s {{.Name | toInitials}}")
    {{ if gt (len .SearchFields) 0 }}
    likeExpr := " ILIKE CONCAT('%', ?::text, '%')"
    if !isPG { likeExpr = " LIKE '%' || ? || '%'" }
    {{- end}}

    {{- range $i, $field := $.SearchFields }}
    if val, ok := searchTerm["{{ $field | getBase }}"]; ok && val != "" {
        {{- if $field | isValid }}
           qb = qb.Where("{{$.Name | toInitials}}.{{ $field | getBase }}" + likeExpr, val)
        {{- else }}
           qb = qb.Where("{{$.Name | toInitials}}.{{ $field | getBase }} = ?", val)
        {{- end}}
    }
    {{- end}}

    qb = qb.OrderBy("id DESC").Limit(pagination.Size).Offset((pagination.Page - 1) * pagination.Size)
    query, args, err := qb.ToSql()
    if err != nil { return 0, err }

    finalitems := (*out)[:0]
    var totalCount int64

    item := models.{{.Name}}GetItemPool.Get()
	defer models.{{.Name}}GetItemPool.Put(item)

    // NATIVE POOL BRANCH: This is the logic that fixes the 11GB allocation
    if s.NativePool != nil {
        rows, err := s.NativePool.Query(ctx, query, args...)
        if err != nil { return 0, err }
        defer rows.Close()
        for rows.Next() {

            err := rows.Scan(
                {{- range .Fields}}{{- if ne .DBType "None"}} &item.{{.Name}}, {{- end }}{{- end }}
                &totalCount,
            )
            finalitems = append(finalitems, *item)
			if err != nil {
				item.Reset()
				return 0, err
			}
			item.Reset()
        }
        *out = finalitems
        return uint(totalCount), nil
    }

    // FALLBACK BRANCH (Standard SQL)
    rows, err := s.SQLC.QueryContext(ctx, query, args...)
    if err != nil { return 0, err }
    defer rows.Close()
    for rows.Next() {

        err := rows.Scan(
            {{- range .Fields}}{{- if ne .DBType "None"}} &item.{{.Name}}, {{- end }}{{- end }}
            &totalCount,
        )
        finalitems = append(finalitems, *item)
        if err != nil {
            item.Reset()
            return 0, err
        }
        item.Reset()
    }
    *out = finalitems
    return uint(totalCount), nil
}

// Update modifies a {{.Name}} by ID
func (s *{{ .AppName | toPascalCase }}Repository) Update{{.Name}}(ctx context.Context, id string, patch_{{.LowerName}} *models.{{.Name}}Patch, tx any, out *models.{{.Name}}) error {
    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    qb.Update("{{ .Name | toSnakeCase }}s")
    {{- range .Fields}} {{- if .Patch}}
    if patch_{{$.LowerName}}.{{.Name}} != nil {
        {{- if eq .Name "Password" }}
        hashed, _ := models.HashPassword(*patch_{{$.LowerName}}.Password)
        qb = qb.Set("{{.Name | toSnakeCase }}", hashed)
        {{- else }}
        qb = qb.Set("{{.Name | toSnakeCase }}", *patch_{{$.LowerName}}.{{.Name}})
        {{- end }}
    }
    {{- end}}{{- end}}

    qb.SetExpr("updated_at", "CURRENT_TIMESTAMP").Where("id = ?", id).Suffix("RETURNING *")
    query, args, _ := qb.ToSql()

    row := s.execQueryRow(ctx, tx, query, args...)
    err := row.Scan(
        {{- range .Fields}}{{- if ne .DBType "None"}} &out.{{.Name}}, {{- end }}{{- end }}
        &out.UpdatedAt, &out.CreatedAt,
    )

    if err == nil { s.Cache.Delete("{{.LowerName}}:" + id) }
    return err
}

// Delete removes a {{.LowerName}} by ID
func (s *{{ .AppName | toPascalCase }}Repository) Delete{{.Name}}(ctx context.Context, id string, tx any) error {
    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    qb.Delete("{{.Name | toSnakeCase }}s").Where("id", id)
    query, args, _ := qb.ToSql()

    var err error
    switch t := tx.(type) {
    case pgx.Tx:
        _, err = t.Exec(ctx, query, args...)
    case *sql.Tx:
        _, err = t.ExecContext(ctx, query, args...)
    default:
        if s.NativePool != nil {
            _, err = s.NativePool.Exec(ctx, query, args...)
        } else {
            _, err = s.SQLC.ExecContext(ctx, query, args...)
        }
    }

    if err == nil { s.Cache.Delete("{{.LowerName}}:" + id) }
    return err
}

// Pre-defined at package level to avoid heap allocation per call.
var {{.LowerName }}InsertColumns = []string{
    {{- if .SnowFlake }}"id",{{- end }}
    {{- $i := 0 -}}
    {{- range .Fields -}}
        {{- if and (or .Post (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") -}}
            {{- if gt $i 0}}, {{end}}"{{.Name | toSnakeCase}}"
            {{- $i = add $i 1 -}}
        {{- end -}}
    {{- end -}}
}

func (s *{{ .AppName | toPascalCase }}Repository) BatchCreate{{.Name}}s(ctx context.Context, posted_{{.LowerName}}s []models.{{.Name}}Post, tx any) error {
    count := len(posted_{{.LowerName}}s)
    if count == 0 { return nil }
    if count > 1000 { return fmt.Errorf("batch size exceeds maximum limit of 1000") }

    // --- PATH A: NATIVE POSTGRES (CopyFrom) ---
    if s.NativePool != nil && tx == nil {
        _, err := s.NativePool.CopyFrom(
            ctx,
            pgx.Identifier{"{{.Name | toSnakeCase}}s"},
            {{.LowerName}}InsertColumns,
            pgx.CopyFromSlice(count, func(i int) ([]any, error) {
                p := &posted_{{.LowerName}}s[i]
                {{ if $break_3 }}u, _ := uuid.NewV7(); uStr := u.String();{{- end }}
                {{- range .Fields }}{{ if eq .Name "Password" }}hashedPassword, _ := models.HashPassword(*p.Password);{{ end }}{{ end }}

                return []any{
                    {{- if .SnowFlake }} s.SnowFlake.GenerateShort(),{{- end }}
                    {{- range .Fields }}
                        {{- if and (or .Post (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") }}
                            {{ if eq .Name "Password" }} hashedPassword,
                            {{ else if eq .Name "UUID" }} uStr,
                            {{ else if eq .Type "bool" }} (p.{{.Name}} != nil && *p.{{.Name}}),
                            {{ else }} p.{{.Name}},
                            {{- end }}
                        {{- end }}
                    {{- end }}
                }, nil
            }),
        )
        return err
    }

    // --- PATH B: FALLBACK ---
    flatPtr := common.FlatArgPool.Get().(*[]any)
    flat := (*flatPtr)[:0]
    defer func() {
        *flatPtr = flat
        common.FlatArgPool.Put(flatPtr)
    }()

    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    rows := make([][]any, count)
    {{ $colCount := 0 -}}
    {{- if .SnowFlake }}{{ $colCount = 1 }}{{ end -}}
    {{- range .Fields -}}{{ if and (or .Post (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") }}{{ $colCount = add $colCount 1 }}{{ end }}{{ end -}}

    for i := 0; i < count; i++ {
        p := &posted_{{.LowerName}}s[i]
        startIdx := len(flat)
        {{ if $break_3 }}u, _ := uuid.NewV7(); uStr := u.String();{{- end }}
        {{- range .Fields }}{{ if eq .Name "Password" }}hashedPassword, _ := models.HashPassword(*p.Password);{{ end }}{{ end }}

        {{- if .SnowFlake }} flat = append(flat, s.SnowFlake.GenerateShort()){{- end }}
        {{- range .Fields }}
            {{- if and (or .Post (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") }}
                {{ if eq .Name "Password" }} flat = append(flat, hashedPassword)
                {{ else if eq .Name "UUID" }} flat = append(flat, uStr)
                {{ else if eq .Type "bool" }} flat = append(flat, (p.{{.Name}} != nil && *p.{{.Name}}))
                {{ else }} flat = append(flat, p.{{.Name}})
                {{- end }}
            {{- end }}
        {{- end }}
        rows[i] = flat[startIdx : startIdx+{{ $colCount }}]
    }

    qb.BatchInsert("{{.Name | toSnakeCase }}s", {{.LowerName}}InsertColumns, rows...).
        SetExpr("created_at", "CURRENT_TIMESTAMP")

    query, args, err := qb.ToSql()
    if err != nil { return err }

    switch t := tx.(type) {
    case pgx.Tx:
        _, err = t.Exec(ctx, query, args...)
    case *sql.Tx:
        _, err = t.ExecContext(ctx, query, args...)
    default:
        _, err = s.SQLC.ExecContext(ctx, query, args...)
    }
    return err
}
