package repository

import (
    "context"
    "fmt"
    "database/sql"
    {{- $break_3 := false }}
    {{- range .Fields }}
        {{- if eq .Name "UUID" }}
            {{- $break_3 = true }}
        {{- end }}
    {{- end }}

    {{- if $break_3 }}
    "github.com/google/uuid"
    {{- end }}
    "{{ .ProjectName }}/{{ $.AppName }}/models"
    "{{ .ProjectName }}/querybuilder"
    "{{ .ProjectName }}/common"
    "github.com/jackc/pgx/v5"
)


// Create inserts a new {{.LowerName}}
func (s *{{ .AppName | toPascalCase }}Repository) Create{{.Name}}(ctx context.Context, posted_{{.LowerName}} *models.{{.Name}}Post, tx any, out *models.{{.Name}}) error {
    {{- range .Fields}} {{- if .Post}}
        {{- if eq .Name "Password" }}
    hashedPassword, _ := models.HashPassword(*posted_{{$.LowerName}}.Password)
        {{- end }}
    {{- end }}
    {{- if eq .Name "UUID" }}
    {{$.LowerName}}_uuid, _ := uuid.NewV7()
    {{- end }}
    {{- end }}

    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()
    
    qb.Insert("{{.LowerName}}s").Columns(
        {{- $i := 0 -}}
        {{- range .Fields -}}
            {{- if and (or .Post (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") -}}
                {{- if gt $i 0}}, {{end}}"{{.Name | toSnakeCase}}"
                {{- $i = add $i 1 -}}
            {{- end -}}
        {{- end -}}
    ).Values(
        {{- range .Fields}} {{- if .Post}}
            {{- if eq .Name "Password" }} hashedPassword,
            {{- else if eq .Name "UUID" }} {{$.LowerName}}_uuid.String(),
            {{- else if eq .Type "bool" }} *posted_{{$.LowerName}}.{{.Name}},
            {{- else }} posted_{{$.LowerName}}.{{.Name}},
            {{- end }}
        {{- end }}
        {{- if eq .Name "UUID" }} {{$.LowerName}}_uuid.String(), {{- end }}
        {{- end }}
    )
        
    qb.SetExpr("created_at", "CURRENT_TIMESTAMP").Suffix("RETURNING *")
    query, args, err := qb.ToSql()
    if err != nil { return err }

    row := s.execQueryRow(ctx, tx, query, args...)

    var item models.{{.Name}}
    err = row.Scan(
      {{- range .Fields}}{{- if ne .DBType "None"}} &item.{{.Name}}, {{- end }}{{- end }}
       &item.UpdatedAt, &item.CreatedAt,
    )
    if err != nil { return err }
    if out != nil { *out = item }
    return nil
}

// GetOne fetches a {{.LowerName}} by ID
func (s *{{ .AppName | toPascalCase }}Repository) GetOne{{.Name}}(ctx context.Context, id string, out *models.{{.Name}}) error {
    cacheKey := "{{.LowerName}}:" + id
    if cached, found := s.Cache.Get(cacheKey); found {
        *out = *(cached.(*models.{{.Name}}))
        return nil
    }

    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()
    
    qb.Select("*").From("{{.LowerName}}s").Where("id = ?", id)
    query, args, _ := qb.ToSql()

    var err error
    if s.NativePool != nil {
        err = s.NativePool.QueryRow(ctx, query, args...).Scan(
            {{- range .Fields}}{{- if ne .DBType "None"}} &out.{{.Name}}, {{- end }}{{- end }}
            &out.UpdatedAt, &out.CreatedAt,
        )
    } else {
        err = s.SQLC.QueryRowContext(ctx, query, args...).Scan(
            {{- range .Fields}}{{- if ne .DBType "None"}} &out.{{.Name}}, {{- end }}{{- end }}
            &out.UpdatedAt, &out.CreatedAt,
        )
    }

    if err == nil { s.Cache.Set(cacheKey, out) }
    return err
}

{{ if gt (len .GetOneFields) 0 }}
{{ range $i, $field := .GetOneFields }}

// Get{{$.Name}}By{{ $field | getBase | toPascalCase }} fetches a {{$.LowerName}} by {{ $field | getBase }}
func (s *{{ $.AppName | toPascalCase }}Repository) Get{{$.Name}}By{{ $field | getBase | toPascalCase }}(ctx context.Context, {{ $field | toSnakeCase }} string, out *models.{{$.Name}}) error {
    // checking Cache if it exists
    cacheKey := "{{$.LowerName}}:" + {{ $field | toSnakeCase }}
    if cached, found := s.Cache.Get(cacheKey); found {
        *out = *(cached.(*models.{{$.Name}}))
        return nil
    }

    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    qb.Select("{{$.Name | toInitials}}.*").
        From("{{$.LowerName}}s {{$.Name | toInitials}}").
        Where("{{$.Name | toInitials}}.{{ $field | getBase }}= ?", {{ $field | toSnakeCase }})

    query, args, err := qb.ToSql()
    if err != nil {
        return fmt.Errorf("failed to build SQL: %v", err)
    }

    // NATIVE POOL BRANCH
    if s.NativePool != nil {
        err = s.NativePool.QueryRow(ctx, query, args...).Scan(
            {{- range $.Fields}}{{- if .Get }} 
            &out.{{.Name}},
            {{- end }}{{- end }}
            &out.UpdatedAt,
            &out.CreatedAt,
        )
    } else {
        // FALLBACK BRANCH
        err = s.SQLC.QueryRowContext(ctx, query, args...).Scan(
            {{- range $.Fields}}{{- if .Get }} 
            &out.{{.Name}},
            {{- end }}{{- end }}
            &out.UpdatedAt,
            &out.CreatedAt,
        )
    }
    
    if err != nil {
        return err
    }

    if out != nil {
        cachedCopy := *out
        s.Cache.Set(cacheKey, &cachedCopy)
    }

    return nil
}
{{ end }}{{- end }}

// Get{{.Name}}s returns resources with high-perf native pool branch
func (s *{{ .AppName | toPascalCase }}Repository) Get{{.Name}}s(ctx context.Context, pagination models.Pagination, searchTerm map[string]string, out *[]models.{{.Name}}Get) (uint, error) {
    isPG := s.DB.Dialector.Name() == "postgres" 
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()
    
    qb.Select("{{.Name | toInitials}}.id", 
    {{- $i := 0 -}}
    {{- range .Fields -}}
        {{- if and (or .Get (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") -}}
            {{- if gt $i 0}}, {{end}}"{{$.Name | toInitials}}.{{.Name | toSnakeCase}}"
            {{- $i = add $i 1 -}}
        {{- end -}}
    {{- end -}}, "count(*) OVER() as total_count").From("{{.LowerName}}s {{.Name | toInitials}}")
    {{ if gt (len .SearchFields) 0 }}
    likeExpr := " ILIKE CONCAT('%', ?::text, '%')"
    if !isPG { likeExpr = " LIKE '%' || ? || '%'" }
    {{- end}}

    {{- range $i, $field := $.SearchFields }}
    if val, ok := searchTerm["{{ $field | getBase }}"]; ok && val != "" {
        {{- if $field | isValid }} 
           qb = qb.Where("{{$.Name | toInitials}}.{{ $field | getBase }}" + likeExpr, val)
        {{- else }}
           qb = qb.Where("{{$.Name | toInitials}}.{{ $field | getBase }} = ?", val)
        {{- end}}
    }
    {{- end}}

    qb = qb.OrderBy("id DESC").Limit(pagination.Size).Offset((pagination.Page - 1) * pagination.Size)
    query, args, err := qb.ToSql()
    if err != nil { return 0, err }

    finalitems := (*out)[:0]
    var totalCount int64

    item := models.{{.Name}}GetItemPool.Get()
	defer models.{{.Name}}GetItemPool.Put(item)

    // NATIVE POOL BRANCH: This is the logic that fixes the 11GB allocation
    if s.NativePool != nil {
        rows, err := s.NativePool.Query(ctx, query, args...)
        if err != nil { return 0, err }
        defer rows.Close()
        for rows.Next() {
            
            err := rows.Scan(
                {{- range .Fields}}{{- if ne .DBType "None"}} &item.{{.Name}}, {{- end }}{{- end }}
                &totalCount,
            )
            finalitems = append(finalitems, *item)
			if err != nil {
				item.Reset()
				return 0, err
			}
			item.Reset()
        }
        *out = finalitems
        return uint(totalCount), nil
    }

    // FALLBACK BRANCH (Standard SQL)
    rows, err := s.SQLC.QueryContext(ctx, query, args...)
    if err != nil { return 0, err }
    defer rows.Close()
    for rows.Next() {

        err := rows.Scan(
            {{- range .Fields}}{{- if ne .DBType "None"}} &item.{{.Name}}, {{- end }}{{- end }}
            &totalCount,
        )
        finalitems = append(finalitems, *item)
        if err != nil {
            item.Reset()
            return 0, err
        }
        item.Reset()
    }
    *out = finalitems
    return uint(totalCount), nil
}

// Update modifies a {{.Name}} by ID
func (s *{{ .AppName | toPascalCase }}Repository) Update{{.Name}}(ctx context.Context, id string, patch_{{.LowerName}} *models.{{.Name}}Patch, tx any, out *models.{{.Name}}) error {
    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()
    
    qb.Update("{{ .LowerName}}s")
    {{- range .Fields}} {{- if .Patch}}
    if patch_{{$.LowerName}}.{{.Name}} != nil {
        {{- if eq .Name "Password" }}
        hashed, _ := models.HashPassword(*patch_{{$.LowerName}}.Password)
        qb = qb.Set("{{.Name | toSnakeCase }}", hashed)
        {{- else }}
        qb = qb.Set("{{.Name | toSnakeCase }}", *patch_{{$.LowerName}}.{{.Name}})
        {{- end }}
    }
    {{- end}}{{- end}}

    qb.SetExpr("updated_at", "CURRENT_TIMESTAMP").Where("id = ?", id).Suffix("RETURNING *")
    query, args, _ := qb.ToSql()

    row := s.execQueryRow(ctx, tx, query, args...)
    err := row.Scan(
        {{- range .Fields}}{{- if ne .DBType "None"}} &out.{{.Name}}, {{- end }}{{- end }}
        &out.UpdatedAt, &out.CreatedAt,
    )
  
    if err == nil { s.Cache.Delete("{{.LowerName}}:" + id) }
    return err
}

// Delete removes a {{.LowerName}} by ID
func (s *{{ .AppName | toPascalCase }}Repository) Delete{{.Name}}(ctx context.Context, id string, tx any) error {
    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()
        
    qb.Delete("{{.LowerName}}s").Where("id", id)
    query, args, _ := qb.ToSql()

    var err error
    switch t := tx.(type) {
    case pgx.Tx:
        _, err = t.Exec(ctx, query, args...)
    case *sql.Tx:
        _, err = t.ExecContext(ctx, query, args...)
    default:
        if s.NativePool != nil {
            _, err = s.NativePool.Exec(ctx, query, args...)
        } else {
            _, err = s.SQLC.ExecContext(ctx, query, args...)
        }
    }

    if err == nil { s.Cache.Delete("{{.LowerName}}:" + id) }
    return err
}

// Pre-defined at package level to avoid heap allocation per call.
var {{.LowerName}}InsertColumns = []string{
    {{- $i := 0 -}}
    {{- range .Fields -}}
        {{- if and (or .Post (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") -}}
            {{- if gt $i 0}}, {{end}}"{{.Name | toSnakeCase}}"
            {{- $i = add $i 1 -}}
        {{- end -}}
    {{- end -}}
}

func (s *{{ .AppName | toPascalCase }}Repository) BatchCreate{{.Name}}s(ctx context.Context, posted_{{.LowerName}}s []models.{{.Name}}Post, tx any) error {
    count := len(posted_{{.LowerName}}s)
    if count == 0 {
        return nil
    }

    if count > 1000 {
        return fmt.Errorf("batch size exceeds maximum limit of 1000")
    }

    // --- PATH A: NATIVE POSTGRES (CopyFrom Protocol) ---
    // This is the fastest way to insert multiple rows in Postgres
    if s.NativePool != nil && tx == nil {
        _, err := s.NativePool.CopyFrom(
            ctx,
            pgx.Identifier{"{{.LowerName}}s"},
            {{.LowerName}}InsertColumns,
            pgx.CopyFromSlice(count, func(i int) ([]any, error) {
                p := &posted_{{.LowerName}}s[i]
                {{ if $break_3 }}u, _ := uuid.NewV7(); uStr := u.String();{{- end }}
                {{- range .Fields }}{{ if eq .Name "Password" }}hashedPassword, _ := models.HashPassword(*p.Password);{{ end }}{{ end }}
                
                return []any{
                    {{- range .Fields }}
                        {{- if and (or .Post (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") }}
                            {{ if eq .Name "Password" }} hashedPassword,
                            {{ else if eq .Name "UUID" }} uStr,
                            {{ else if eq .Type "bool" }} (p.{{.Name}} != nil && *p.{{.Name}}),
                            {{ else }} p.{{.Name}},
                            {{- end }}
                        {{- end }}
                    {{- end }}
                }, nil
            }),
        )
        return err
    }

    // --- PATH B: FALLBACK (Standard Batch Insert) ---
    // Used if we are in a transaction or not using Postgres
    flatPtr := common.FlatArgPool.Get().(*[]any)
    flat := (*flatPtr)[:0]
    defer func() {
        *flatPtr = flat
        common.FlatArgPool.Put(flatPtr)
    }()

    isPG := s.DB.Dialector.Name() == "postgres"
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    rows := make([][]any, count)
    {{ $colCount := 0 -}}
    {{- range .Fields -}}{{ if and (or .Post (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") }}{{ $colCount = add $colCount 1 }}{{ end }}{{ end -}}
    const colCount = {{ $colCount }}

    for i := 0; i < count; i++ {
        p := &posted_{{.LowerName}}s[i]
        startIdx := len(flat)
        {{ if $break_3 }}u, _ := uuid.NewV7(); uStr := u.String();{{- end }}
        {{- range .Fields }}{{ if eq .Name "Password" }}hashedPassword, _ := models.HashPassword(*p.Password);{{ end }}{{ end }}

        {{- range .Fields }}
            {{- if and (or .Post (eq .Name "Password") (eq .Name "UUID")) (ne .Name "ID") (ne .Name "CreatedAt") }}
                {{ if eq .Name "Password" }} flat = append(flat, hashedPassword)
                {{ else if eq .Name "UUID" }} flat = append(flat, uStr)
                {{ else if eq .Type "bool" }} flat = append(flat, (p.{{.Name}} != nil && *p.{{.Name}}))
                {{ else }} flat = append(flat, p.{{.Name}})
                {{- end }}
            {{- end }}
        {{- end }}
        rows[i] = flat[startIdx : startIdx+colCount]
    }

    qb.BatchInsert("{{.LowerName}}s", {{.LowerName}}InsertColumns, rows...).
        SetExpr("created_at", "CURRENT_TIMESTAMP")

    query, args, err := qb.ToSql()
    if err != nil { return err }

    switch t := tx.(type) {
    case pgx.Tx:
        _, err = t.Exec(ctx, query, args...)
    case *sql.Tx:
        _, err = t.ExecContext(ctx, query, args...)
    default:
        _, err = s.SQLC.ExecContext(ctx, query, args...)
    }
    return err
}   