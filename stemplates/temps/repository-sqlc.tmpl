package repository

import (
	"context"
	"fmt"
	"strconv"
	{{- $break_3 := false }}
	{{- range .Fields }}
		{{- if eq .Name "UUID" }}
			{{- $break_3 = true }}
		{{- end }}
	{{- end }}

	{{- if $break_3 }}
	"github.com/google/uuid"
	{{- end }}
   	"{{ .ProjectName }}/{{ $.AppName }}/models"
	"{{ .ProjectName }}/querybuilder"
	 "database/sql"
   
)



// Create inserts a new {{.LowerName}}
func (s *{{ .AppName | toPascalCase }}Repository) Create{{.Name}}(ctx context.Context, posted_{{.LowerName}} *models.{{.Name}}Post, tx *sql.Tx,out *models.{{.Name}}) error {

        {{- range .Fields}} {{- if .Post}}
            {{- if eq .Name "Password" }}
        hashedPassword,_ := models.HashPassword(posted_{{$.LowerName}}.Password)
        // hashedPassword,_ := models.HashFunc(posted_{{$.LowerName}}.Password,s.Cfg))
            {{- end }}
        {{- end }}
        {{- if eq .Name "UUID" }}
        {{$.LowerName}}_uuid, _ := uuid.NewV7()
            {{- end }}
        {{- end }}

        isPG := s.DB.Dialector.Name() == "postgres"
        qb := querybuilder.GetBuilder(isPG)
        defer qb.Release()
        
        qb.Insert("{{.LowerName}}s").Columns(
        {{- $i := 0 -}}
            {{- range .Fields -}}
            {{- if and
                    (or .Post (eq .Name "Password") (eq .Name "UUID"))
                    (ne .Name "ID")
                    (ne .Name "CreatedAt")
            -}}
                {{- if gt $i 0}}, {{end}}"{{.Name | toSnakeCase}}"
                {{- $i = add $i 1 -}}
                
            {{- end -}}
            {{- end -}}
        ).Values(
            {{- range .Fields}} {{- if .Post}}
            {{- if eq .Name "Password" }}
                hashedPassword,
            {{- else if eq .Name "UUID" }}
                {{$.LowerName}}_uuid.String(),
            {{- else if eq .Type "bool" }}
                *posted_{{.ModelName | toLowerCaseName }}.{{.Name}},
            {{- else }}
                posted_{{.ModelName | toLowerCaseName }}.{{.Name}},
            {{- end	}}
        {{- end}}
            {{- if eq .Name "UUID" }}
               {{$.LowerName}}_uuid.String(),
            {{- end }}
        {{- end}}
            
        )

        
    // set created date
	qb.SetExpr("created_at", "CURRENT_TIMESTAMP").
        Suffix("RETURNING {{.LowerName}}s.*")

    // 3. Build SQL
	query, args, err := qb.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build SQL: %v", err)
	}

    // Execute the query using sqlc
    row := tx.QueryRowContext(ctx,query,args...)

	var item models.{{.Name}}
	err = row.Scan(
	  {{- range .Fields}}{{- if ne .DBType  "None"}} 
        &item.{{.Name}},
      {{- end }}{{- end }}
       &item.UpdatedAt,
       &item.CreatedAt,
	)
    if err != nil {
        return err
    }
    if out != nil {
        *out = item
    }
	return nil
}


// GetOne fetches a {{.LowerName}} by ID
func (s *{{ .AppName | toPascalCase }}Repository) GetOne{{.Name}}(ctx context.Context, id string,out *models.{{.Name}}) (error) {
    // checking Cache if it exists
   	cacheKey := "{{.LowerName}}:" + id
	if cached{{.Name}}, found := s.Cache.Get(cacheKey); found {
		*out = *(cached{{.Name}}.(*models.{{.Name}}))
        return nil
	}


	objID, err := strconv.Atoi(id)
	if err != nil {
		return fmt.Errorf("invalid ID: %v", err)
	}

    isPG := s.DB.Dialector.Name() == "postgres"

    // Build the query
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()
    
    qb.Select("{{.Name | toInitials}}.*").
            From("{{.LowerName}}s {{.Name | toInitials}}").
            Where("{{.Name | toInitials}}.id= ?",objID)
  

    query, args, err := qb.ToSql()
    if err != nil {
        return fmt.Errorf("failed to build SQL: %v", err)
    }

    // 4. Execute the query
    row := s.SQLC.QueryRowContext(ctx, query, args...)
   

	var item models.{{.Name}}
	err = row.Scan(
	  {{- range .Fields}}{{- if ne .DBType  "None"}} 
        &item.{{.Name}},
      {{- end }}{{- end }}
      &item.UpdatedAt,
	  &item.CreatedAt,
	)
	
    if err != nil {
		return  err
	}

    if out != nil {
		*out = item
        cachedCopy := item
		s.Cache.Set(cacheKey, &cachedCopy)
	}


	return nil
}

{{ if gt (len .GetOneFields) 0 }}
{{ range $i, $field := .GetOneFields }}

// GetOne fetches a {{$.LowerName}} by {{ $field | getBase | toPascalCase }}
func (s *{{ $.AppName | toPascalCase }}Repository) Get{{$.Name}}By{{ $field | getBase | toPascalCase }}(ctx context.Context, {{ $field | toSnakeCase }} string, out *models.{{$.Name}}) (error) {
    // checking Cache if it exists
   	cacheKey := "{{$.LowerName}}:" + {{ $field | toSnakeCase}}
	if cached{{$.Name}}, found := s.Cache.Get(cacheKey); found {
		*out = *(cached{{$.Name}}.(*models.{{$.Name}}))
        return nil
	}

    isPG := s.DB.Dialector.Name() == "postgres"
    // Build the query
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()

    qb.Select("{{$.Name | toInitials}}.*").
        From("{{$.LowerName}}s {{$.Name | toInitials}}").
        Where("{{$.Name | toInitials}}.{{ $field | getBase }}= ?",{{ $field | toSnakeCase }})

    query, args, err := qb.ToSql()
    if err != nil {
        return fmt.Errorf("failed to build SQL: %v", err)
    }

    // 4. Execute the query
    row := s.SQLC.QueryRowContext(ctx, query, args...)
   
	var item models.{{$.Name}}
	err = row.Scan(
	  {{- range $.Fields}}{{- if .Get }} 
        &item.{{.Name}},
      {{- end }}{{- end }}
      &item.UpdatedAt,
		&item.CreatedAt,
	)
	
    if err != nil {
		return  err
	}

    if out != nil {
		*out = item
        cachedCopy := item
		s.Cache.Set(cacheKey, &cachedCopy)
	}


	return nil
}
{{ end }}{{- end }}

// Get returns {{.LowerName}}s with pagination and search
func (s *{{ .AppName | toPascalCase }}Repository) Get{{.Name}}s(ctx context.Context, pagination models.Pagination, searchTerm map[string]any, out *[]models.{{.Name}}Get) (uint, error) {
    isPG := s.DB.Dialector.Name() == "postgres" 
    qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()
    
    qb.Select("{{.Name | toInitials}}.*", "count(*) OVER() as total_count").
        From("{{.LowerName}}s {{.Name | toInitials}}")
   

    {{ if gt (len .SearchFields) 0 }}
    // Dialect-aware LIKE operator
	likeExpr := " ILIKE CONCAT('%', ?::text, '%')"
	if !isPG {
		likeExpr = " LIKE '%' || ? || '%'"
	}

    {{- end}}

    {{- range $i, $field := $.SearchFields }}
    // Handle searchTerm nil values
    {{ $field | getBase }}, ok := searchTerm["{{ $field | getBase }}"]
    {{- if $field | isValid }} 
        if ok && searchTerm["{{ $field | getBase }}"] != "" {
           qb = qb.Where("{{$.Name | toInitials}}.{{ $field | getBase }}" + likeExpr,{{ $field | getBase }})  // You can set it to "" or leave it as nil, depending on your query's COALESCE logic
        }    
    {{- else }}
        if ok && searchTerm["{{ $field | getBase }}"] != nil && {{ $field | getBase }} != "" {
           qb = qb.Where("{{$.Name | toInitials}}.{{ $field | getBase }} = ?",{{ $field | getBase }})
        }
    {{- end}}
    {{- end}}

    // Apply pagination with LIMIT and OFFSET
	qb = qb.OrderBy("id DESC").
		Limit(pagination.Size).
		Offset((pagination.Page - 1) * pagination.Size)

	// Build the query string and parameters
	query, args, err := qb.ToSql()
	if err != nil {
		return  0, fmt.Errorf("failed to build SQL query: %v", err)
	}

    // Reset the slice length to 0 (but keep the pooled capacity)
	finalitems := (*out)[:0]

	// Execute the query using sqlc
	rows, err := s.SQLC.QueryContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
    defer rows.Close()

   
    item := models.{{.Name}}GetPool.Get()
    var totalCount int64
    for rows.Next() {
        err := rows.Scan(
          {{- range .Fields}}{{- if ne .DBType  "None"}} 
            &item.{{.Name}},
          {{- end }}{{- end }}
          &item.UpdatedAt,
          &item.CreatedAt,
            &totalCount,
        )

        finalitems = append(finalitems, *item)
        if err != nil {
            models.{{.Name}}GetPool.Put(item)
            return 0, err
        }
        item.Reset()
    }
    models.{{.Name}}GetPool.Put(item)
    *out = finalitems

	return uint(totalCount), nil
}



// Update modifies a {{.Name}}s by ID
func (s *{{ .AppName | toPascalCase }}Repository) Update{{.Name}}(ctx context.Context, id string ,patch_{{.LowerName}} *models.{{.Name}}Patch,tx  *sql.Tx, out *models.{{.Name}}) (error) {
    isPG := s.DB.Dialector.Name() == "postgres"

	qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()
    
    qb.Update("{{ .LowerName}}s")
    
    {{- range .Fields}} {{- if .Patch}}
    {{- if eq .Name "Password" }}
    if patch_{{$.LowerName}}.{{.Name}} != nil {
        // setting password string to hash
        hashedPassword,_ := models.HashPassword(*patch_{{$.LowerName}}.Password)
        qb = qb.Set("{{.Name | camelToSnake }}",hashedPassword)
    }
    {{- else if eq .Name "ID" }} 
    
    {{- else if eq .Type "bool" }}
     if patch_{{$.LowerName}}.{{.Name}} != nil {
        qb = qb.Set("{{.Name | camelToSnake }}", *patch_{{$.LowerName}}.{{.Name}})
        }
    {{- else }}
    if patch_{{$.LowerName}}.{{.Name}} != nil {
        qb = qb.Set("{{.Name | camelToSnake }}", *patch_{{$.LowerName}}.{{.Name}})
    }
    {{- end	}}
    {{- end}}
    {{- end}}



	qb.SetExpr("updated_at", "CURRENT_TIMESTAMP").
		Where("id = ?", id).
		Suffix("RETURNING *")

    
    // Build the query string and parameters
	query, args, err := qb.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build SQL query: %v", err)
	}

    // Execute the query using sqlc
	row := tx.QueryRowContext(ctx, query, args...)

	var item models.{{.Name}}
	err = row.Scan(
	  {{- range .Fields}}{{- if ne .DBType  "None"}}  
        &item.{{.Name}},
      {{- end }}{{- end }}
       &item.UpdatedAt,
       &item.CreatedAt,
	)
  
    if err != nil {
        return  err
    }

    if out != nil {
        *out = item
    }   

    // Removing Cache if update success
    cacheKey := "{{.LowerName}}:" + strconv.FormatUint(uint64(item.ID),10)
    s.Cache.Delete(cacheKey)
    {{- if and (eq .AppName .AuthAppName) (eq .Name "User") }}
    email := item.Email
    s.Cache.Delete("user:login:" + email)
    {{- end }}

	return nil
}


// Delete removes a {{.LowerName}} by ID
func (s *{{ .AppName | toPascalCase }}Repository) Delete{{.Name}}(ctx context.Context, id string, tx *sql.Tx) error {


    // Build the delete query
    isPG := s.DB.Dialector.Name() == "postgres"

	qb := querybuilder.GetBuilder(isPG)
    defer qb.Release()
        
    qb.Delete("{{.LowerName}}s").Where("id", id){{- if and (eq .AppName .AuthAppName) (eq .Name "User") }}.
         Suffix("RETURNING email") {{- end }}

   
	// 3. Generate SQL string and arguments
	query, args, err := qb.ToSql()
	if err != nil {
		return fmt.Errorf("failed to build delete SQL: %v", err)
	}

	// 4. Execute using the provided transaction (tx)
   

    {{- if and (eq .AppName .AuthAppName) (eq .Name "User") }}
    var email string
	err = tx.QueryRowContext(ctx, query, args...).
        Scan(&email)
	if err != nil {
		return err
	}
    {{- else }}
    _,err = tx.ExecContext(ctx, query, args...)
    if err != nil {
        return err
        }
    {{- end}}

    // Removing Cache if delete success
    cacheKey := "{{.LowerName}}:" + id
    s.Cache.Delete(cacheKey)
    {{- if and (eq .AppName .AuthAppName) (eq .Name "User") }}
    s.Cache.Delete("user:login:" + email)
    {{- end }}


	return err
}
