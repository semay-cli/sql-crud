package common

import (
	"bytes"
	"encoding/json"
	"sync"

	"github.com/bytedance/sonic"
	"github.com/gofiber/fiber/v3"
)

var (
	bufferPool = sync.Pool{
		New: func() any {
			return bytes.NewBuffer(make([]byte, 0, 4096))
		},
	}
	// Reusable Sonic Config
	apiJson = sonic.ConfigDefault
)

// SendJSON is the high-performance engine for Fiber v3
func SendJSON(c fiber.Ctx, status int, v any) error {
	// Set status and headers first
	c.Status(status)
	c.Set(fiber.HeaderContentType, fiber.MIMEApplicationJSON)

	// 1. Get buffer from pool
	buf := bufferPool.Get().(*bytes.Buffer)
	buf.Reset()
	defer bufferPool.Put(buf)

	// 2. Encode directly into the pooled buffer
	// We use the package-level apiJson (Sonic) to avoid config allocation
	if err := apiJson.NewEncoder(buf).Encode(v); err != nil {
		return err
	}

	// 3. Performance Optimization: Sonic adds a newline (\n) at the end.
	// We trim it to save 1 byte per request and keep the output clean.
	data := buf.Bytes()
	if len(data) > 0 && data[len(data)-1] == '\n' {
		data = data[:len(data)-1]
	}

	// 4. In Fiber v3, c.Write is the correct way to send the byte slice.
	_, err := c.Write(data)
	return err
}

// =====================
// Alternative: Standard JSON
// =====================

// SendJSONStd uses standard encoding/json (compatible, less memory)
func SendJSONStd(c fiber.Ctx, status int, v any) error {
	c.Status(status)
	c.Set(fiber.HeaderContentType, fiber.MIMEApplicationJSON)

	buf := bufferPool.Get().(*bytes.Buffer)
	buf.Reset()
	defer bufferPool.Put(buf)

	// Use standard JSON
	enc := json.NewEncoder(buf)
	enc.SetEscapeHTML(false)

	if err := enc.Encode(v); err != nil {
		return err
	}

	// Remove trailing newline
	data := buf.Bytes()
	if len(data) > 0 && data[len(data)-1] == '\n' {
		data = data[:len(data)-1]
	}

	_, err := c.Write(data)
	return err
}

// =====================
// Helper Functions
// =====================

// Success sends a successful JSON response
func Success(c fiber.Ctx, data any) error {
	return SendJSON(c, fiber.StatusOK, fiber.Map{
		"success": true,
		"data":    data,
	})
}

// Error sends an error JSON response
func Error(c fiber.Ctx, status int, message string) error {
	return SendJSON(c, status, fiber.Map{
		"success": false,
		"error":   message,
	})
}
