package repository

import (
	"context"
	"database/sql"
    "regexp"
	"{{ .ProjectName }}/cache"
	"{{ .ProjectName }}/configs"
	"{{ .ProjectName }}/database"
	"{{ .ProjectName }}/utils"
	db "{{ .ProjectName }}/{{ .AppName}}/sqlc"	
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"gorm.io/gorm"
)

type rowScanner interface {
	Scan(dest ...any) error
}

// AppDatabase Service wraps Dababase service(SQL)
type {{ .AppName | toPascalCase }}Repository struct {
	SQLC  *sql.DB
	DB *gorm.DB
	Cache *cache.CacheService
	Queries      *db.Queries 
	NativePool   *pgxpool.Pool
	SnowFlake *utils.Generator
	Cfg   *configs.EnvConfig
	ForeignRegex *regexp.Regexp
    NumberRegex  *regexp.Regexp
}



func InitRepository(client *database.DBBundle , cacheService *cache.CacheService, cfg *configs.EnvConfig) *{{ .AppName | toPascalCase }}Repository {
	snowflakeNode, err := utils.NewGenerator() // Node ID can be any number between 0 and 1023
	if err != nil {
		panic("Failed to initialize Snowflake node: " + err.Error())
	}
	
	return &{{ .AppName | toPascalCase }}Repository{
		SQLC:         client.SQL,
		DB:           client.Gorm,
		Cache:        cacheService,
		Queries:      db.New(client.SQL),
		NativePool:   client.PGX,
		SnowFlake:    snowflakeNode,
		Cfg:   cfg,
	}

}

// wrapTx provides a unified interface for QueryRow regardless of driver
func (s *{{ .AppName | toPascalCase }}Repository) execQueryRow(ctx context.Context, tx any, query string, args ...any) rowScanner {
	switch t := tx.(type) {
	case pgx.Tx:
		return t.QueryRow(ctx, query, args...)
	case *sql.Tx:
		return t.QueryRowContext(ctx, query, args...)
	default:
		// Fallback to pool/connection if no transaction provided
		if s.NativePool != nil {
			return s.NativePool.QueryRow(ctx, query, args...)
		}
		return s.SQLC.QueryRowContext(ctx, query, args...)
	}
}