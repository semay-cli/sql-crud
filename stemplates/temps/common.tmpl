package common

import "sync"

var (
	responseHTTPPool = sync.Pool{
		New: func() any {
			return &ResponseHTTP[any]{}
		},
	}

	responsePaginationPool = sync.Pool{
		New: func() any {
			return &ResponsePagination[any]{}
		},
	}

	searchMapPool = sync.Pool{
		New: func() any {
			return make(map[string]string)
		},
	}
)

// Use Generics to avoid interface{} boxing allocations
type ResponseHTTP[T any] struct {
	Success bool   `json:"success"`
	Data    T      `json:"data"`
	Message string `json:"details"`
}

type ResponsePagination[T any] struct {
	Success bool   `json:"success"`
	Items   T      `json:"data"`
	Message string `json:"details"`
	Total   uint   `json:"total"`
	Page    uint   `json:"page"`
	Pages   uint   `json:"pages"`
	Size    uint   `json:"size"`
}

// Generic function to filter the map based on a list of allowed keys.
func FilterMapByKeys(input map[string]any, allowedKeys []string) map[string]any {
	filtered := make(map[string]any)

	for _, key := range allowedKeys {
		if value, ok := input[key]; ok {
			filtered[key] = value
		}
	}

	return filtered
}

// FilterMapInPlace filters a map[string,T] in place, keeping only allowedKeys
func FilterMapInPlace[T any](input map[string]T, allowedKeys []string) {
	// Build a lookup set for allowed keys
	allowed := make(map[string]struct{}, len(allowedKeys))
	for _, k := range allowedKeys {
		allowed[k] = struct{}{}
	}

	// Remove keys that are not in the allowed list
	for k := range input {
		if _, ok := allowed[k]; !ok {
			delete(input, k)
		}
	}
}

// Generic function to filter the map based on a list of allowed keys.
func FilterSearchTerms(input map[string]any, allowedKeys []string) []string {
	filtered := make([]string, 0)

	for _, key := range allowedKeys {
		if value, ok := input[key]; ok {
			filtered = append(filtered, value.(string))
		}
	}

	return filtered
}

// GetResponseHTTP gets a ResponseHTTP from the pool.
func GetResponseHTTP() *ResponseHTTP[any] {
	return responseHTTPPool.Get().(*ResponseHTTP[any])
}

// PutResponseHTTP resets and returns a ResponseHTTP to the pool.
func PutResponseHTTP(r *ResponseHTTP[any]) {
	r.Success = false
	r.Data = nil
	r.Message = ""
	responseHTTPPool.Put(r)
}

// GetResponsePagination gets a ResponsePagination from the pool.
func GetResponsePagination() *ResponsePagination[any] {
	return responsePaginationPool.Get().(*ResponsePagination[any])
}

// PutResponsePagination resets and returns a ResponsePagination to the pool.
func PutResponsePagination(r *ResponsePagination[any]) {
	r.Success = false
	r.Items = nil
	r.Message = ""
	r.Total = 0
	r.Page = 0
	r.Size = 0
	r.Pages = 0
	responsePaginationPool.Put(r)
}

// GetSearchMap gets a map[string,T] from the pool.
func GetSearchMap() map[string]string {
	if v := searchMapPool.Get(); v != nil {
		return v.(map[string]string)
	}
	return make(map[string]string)
}

// PutSearchMap clears and returns a map[string,T] to the pool.
func PutSearchMap(m map[string]string) {
	for k := range m {
		delete(m, k)
	}
	searchMapPool.Put(m)
}

// argPool handles the heavy lifting of the data to avoid GC scans of thousands of small objects
var FlatArgPool = sync.Pool{
	New: func() any {
		s := make([]any, 0, 1024)
		return &s
	},
}
