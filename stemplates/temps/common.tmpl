package common

import "sync"

var (
	responseHTTPPool = sync.Pool{
		New: func() any {
			return &ResponseHTTP{}
		},
	}

	responsePaginationPool = sync.Pool{
		New: func() any {
			return &ResponsePagination{}
		},
	}

	searchMapPool = sync.Pool{
		New: func() any {
			return make(map[string]string)
		},
	}
)

type ResponseHTTP struct {
	Success bool        `json:"success"`
	Data    interface{} `json:"data"`
	Message string      `json:"details"`
}

type ResponsePagination struct {
	Success bool        `json:"success"`
	Items   interface{} `json:"data"`
	Message string      `json:"details"`
	Total   uint        `json:"total"`
	Page    uint        `json:"page"`
	Size    uint        `json:"size"`
	Pages   uint        `json:"pages"`
}

// Generic function to filter the map based on a list of allowed keys.
func FilterMapByKeys(input map[string]any, allowedKeys []string) map[string]any {
	filtered := make(map[string]any)

	for _, key := range allowedKeys {
		if value, ok := input[key]; ok {
			filtered[key] = value
		}
	}

	return filtered
}

// FilterMapInPlace filters a map[string,T] in place, keeping only allowedKeys
func FilterMapInPlace[T any](input map[string]T, allowedKeys []string) {
	// Build a lookup set for allowed keys
	allowed := make(map[string]struct{}, len(allowedKeys))
	for _, k := range allowedKeys {
		allowed[k] = struct{}{}
	}

	// Remove keys that are not in the allowed list
	for k := range input {
		if _, ok := allowed[k]; !ok {
			delete(input, k)
		}
	}
}


// Generic function to filter the map based on a list of allowed keys.
func FilterSearchTerms(input map[string]any, allowedKeys []string) []string {
	filtered := make([]string, 0)

	for _, key := range allowedKeys {
		if value, ok := input[key]; ok {
			filtered = append(filtered, value.(string))
		}
	}

	return filtered
}

// GetResponseHTTP gets a ResponseHTTP from the pool.
func GetResponseHTTP() *ResponseHTTP {
	return responseHTTPPool.Get().(*ResponseHTTP)
}

// PutResponseHTTP resets and returns a ResponseHTTP to the pool.
func PutResponseHTTP(r *ResponseHTTP) {
	r.Success = false
	r.Data = nil
	r.Message = ""
	responseHTTPPool.Put(r)
}

// GetResponsePagination gets a ResponsePagination from the pool.
func GetResponsePagination() *ResponsePagination {
	return responsePaginationPool.Get().(*ResponsePagination)
}

// PutResponsePagination resets and returns a ResponsePagination to the pool.
func PutResponsePagination(r *ResponsePagination) {
	r.Success = false
	r.Items = nil
	r.Message = ""
	r.Total = 0
	r.Page = 0
	r.Size = 0
	r.Pages = 0
	responsePaginationPool.Put(r)
}


// GetSearchMap gets a map[string,T] from the pool.
func GetSearchMap() map[string]string {
	if v := searchMapPool.Get(); v != nil {
		return v.(map[string]string)
	}
	return make(map[string]string)
}

// PutSearchMap clears and returns a map[string,T] to the pool.
func PutSearchMap(m map[string]string) {
	for k := range m {
		delete(m, k)
	}
	searchMapPool.Put(m)
}
